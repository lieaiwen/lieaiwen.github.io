<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>es6 class | 速度至上</title>
    <meta name="description" content="Reggie Study Notes">
    <meta name="generator" content="VuePress 1.3.0">
    <link rel="icon" href="/dist/img/logo.ico">
  <link rel="manifest" href="/dist/manifest.json">
    
    <link rel="preload" href="/dist/assets/css/0.styles.35364d6e.css" as="style"><link rel="preload" href="/dist/assets/js/app.c917e6cc.js" as="script"><link rel="preload" href="/dist/assets/js/2.47087845.js" as="script"><link rel="preload" href="/dist/assets/js/10.272a0d8f.js" as="script"><link rel="prefetch" href="/dist/assets/js/11.b18936e9.js"><link rel="prefetch" href="/dist/assets/js/12.e6c034ba.js"><link rel="prefetch" href="/dist/assets/js/13.e6607d61.js"><link rel="prefetch" href="/dist/assets/js/14.3dcb46ff.js"><link rel="prefetch" href="/dist/assets/js/15.c98ab082.js"><link rel="prefetch" href="/dist/assets/js/16.b4d38ade.js"><link rel="prefetch" href="/dist/assets/js/17.99b8ec1e.js"><link rel="prefetch" href="/dist/assets/js/18.7fe5e6e5.js"><link rel="prefetch" href="/dist/assets/js/19.7a75dd83.js"><link rel="prefetch" href="/dist/assets/js/20.900a3232.js"><link rel="prefetch" href="/dist/assets/js/21.829fa9a5.js"><link rel="prefetch" href="/dist/assets/js/22.a9af6621.js"><link rel="prefetch" href="/dist/assets/js/23.931d5e65.js"><link rel="prefetch" href="/dist/assets/js/24.b81fd765.js"><link rel="prefetch" href="/dist/assets/js/25.ade77fd1.js"><link rel="prefetch" href="/dist/assets/js/26.57bd2b69.js"><link rel="prefetch" href="/dist/assets/js/27.e432c17e.js"><link rel="prefetch" href="/dist/assets/js/28.770b7223.js"><link rel="prefetch" href="/dist/assets/js/29.a1c0088d.js"><link rel="prefetch" href="/dist/assets/js/3.63fad206.js"><link rel="prefetch" href="/dist/assets/js/30.7e308595.js"><link rel="prefetch" href="/dist/assets/js/31.2d3f011a.js"><link rel="prefetch" href="/dist/assets/js/32.84c6baee.js"><link rel="prefetch" href="/dist/assets/js/33.746c8544.js"><link rel="prefetch" href="/dist/assets/js/34.d2e3b45c.js"><link rel="prefetch" href="/dist/assets/js/35.54e93ddf.js"><link rel="prefetch" href="/dist/assets/js/36.fd9a8d86.js"><link rel="prefetch" href="/dist/assets/js/37.b656b7e3.js"><link rel="prefetch" href="/dist/assets/js/38.7598d92e.js"><link rel="prefetch" href="/dist/assets/js/39.b235fd2a.js"><link rel="prefetch" href="/dist/assets/js/4.bd5c7804.js"><link rel="prefetch" href="/dist/assets/js/40.5b412597.js"><link rel="prefetch" href="/dist/assets/js/41.10e71457.js"><link rel="prefetch" href="/dist/assets/js/42.2adc995a.js"><link rel="prefetch" href="/dist/assets/js/43.7fb986a0.js"><link rel="prefetch" href="/dist/assets/js/44.221d507c.js"><link rel="prefetch" href="/dist/assets/js/45.c01a5315.js"><link rel="prefetch" href="/dist/assets/js/46.27464cbe.js"><link rel="prefetch" href="/dist/assets/js/47.cda53af1.js"><link rel="prefetch" href="/dist/assets/js/48.a97682dd.js"><link rel="prefetch" href="/dist/assets/js/49.31315172.js"><link rel="prefetch" href="/dist/assets/js/5.28d23724.js"><link rel="prefetch" href="/dist/assets/js/50.55f5cfd4.js"><link rel="prefetch" href="/dist/assets/js/51.6dfcf284.js"><link rel="prefetch" href="/dist/assets/js/52.30f62370.js"><link rel="prefetch" href="/dist/assets/js/53.870a03f6.js"><link rel="prefetch" href="/dist/assets/js/54.79e4283b.js"><link rel="prefetch" href="/dist/assets/js/55.d6541f26.js"><link rel="prefetch" href="/dist/assets/js/56.7656c52b.js"><link rel="prefetch" href="/dist/assets/js/57.3155b432.js"><link rel="prefetch" href="/dist/assets/js/58.aa9e6022.js"><link rel="prefetch" href="/dist/assets/js/59.ace2375a.js"><link rel="prefetch" href="/dist/assets/js/6.24776c69.js"><link rel="prefetch" href="/dist/assets/js/60.bbca0748.js"><link rel="prefetch" href="/dist/assets/js/61.4885868f.js"><link rel="prefetch" href="/dist/assets/js/62.adb1f4a1.js"><link rel="prefetch" href="/dist/assets/js/63.42890dc8.js"><link rel="prefetch" href="/dist/assets/js/64.2563c169.js"><link rel="prefetch" href="/dist/assets/js/65.9113a683.js"><link rel="prefetch" href="/dist/assets/js/66.75f88a90.js"><link rel="prefetch" href="/dist/assets/js/67.5ec328fe.js"><link rel="prefetch" href="/dist/assets/js/68.389976e3.js"><link rel="prefetch" href="/dist/assets/js/69.64bb83b1.js"><link rel="prefetch" href="/dist/assets/js/7.5f367344.js"><link rel="prefetch" href="/dist/assets/js/70.013210ce.js"><link rel="prefetch" href="/dist/assets/js/71.f310f6e9.js"><link rel="prefetch" href="/dist/assets/js/72.f6b8ca15.js"><link rel="prefetch" href="/dist/assets/js/73.44de2be4.js"><link rel="prefetch" href="/dist/assets/js/74.eedb9492.js"><link rel="prefetch" href="/dist/assets/js/75.c32d2819.js"><link rel="prefetch" href="/dist/assets/js/76.e98765e3.js"><link rel="prefetch" href="/dist/assets/js/77.9b1efc2a.js"><link rel="prefetch" href="/dist/assets/js/78.9ab31ecd.js"><link rel="prefetch" href="/dist/assets/js/8.5b2229dc.js"><link rel="prefetch" href="/dist/assets/js/9.46cc1f89.js">
    <link rel="stylesheet" href="/dist/assets/css/0.styles.35364d6e.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/dist/" class="home-link router-link-active"><!----> <span class="site-name">速度至上</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/dist/" class="nav-link">
  Home
</a></div><div class="nav-item"><a href="/dist/guide/" class="nav-link">
  Guide
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="Languages" class="dropdown-title"><span class="title">Languages</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/dist/language/chinese.html" class="nav-link">
  Chinese
</a></li><li class="dropdown-item"><!----> <a href="/dist/language/english.html" class="nav-link">
  English
</a></li></ul></div></div><div class="nav-item"><a href="https://www.baidu.com" target="_blank" rel="noopener noreferrer" class="nav-link external">
  External
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/dist/" class="nav-link">
  Home
</a></div><div class="nav-item"><a href="/dist/guide/" class="nav-link">
  Guide
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="Languages" class="dropdown-title"><span class="title">Languages</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/dist/language/chinese.html" class="nav-link">
  Chinese
</a></li><li class="dropdown-item"><!----> <a href="/dist/language/english.html" class="nav-link">
  English
</a></li></ul></div></div><div class="nav-item"><a href="https://www.baidu.com" target="_blank" rel="noopener noreferrer" class="nav-link external">
  External
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>js知识点</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/dist/page-1/one/" class="sidebar-link">数组操作</a></li><li><a href="/dist/page-1/three/" class="sidebar-link">js基础知识2</a></li><li><a href="/dist/page-1/two/" class="sidebar-link">call apply bind</a></li><li><a href="/dist/page-1/Boolean/" class="sidebar-link">Boolean</a></li><li><a href="/dist/page-1/Object/" class="sidebar-link">js对象</a></li><li><a href="/dist/page-1/RegExp/" class="sidebar-link">js RegExp 对象</a></li><li><a href="/dist/page-1/Date/" class="sidebar-link">Date 对象</a></li><li><a href="/dist/page-1/Math/" class="sidebar-link">Math 对象</a></li><li><a href="/dist/page-1/Number/" class="sidebar-link">Number 对象</a></li><li><a href="/dist/page-1/String/" class="sidebar-link">String 对象</a></li><li><a href="/dist/page-1/Error/" class="sidebar-link">js Error(错误)对象</a></li><li><a href="/dist/page-1/Global/" class="sidebar-link">js 全局</a></li><li><a href="/dist/page-1/Class/" class="active sidebar-link">es6 class</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/dist/page-1/Class/#es6-class" class="sidebar-link">es6 class</a></li><li class="sidebar-sub-header"><a href="/dist/page-1/Class/#基础用法" class="sidebar-link">基础用法</a></li><li class="sidebar-sub-header"><a href="/dist/page-1/Class/#类的主体" class="sidebar-link">类的主体</a></li><li class="sidebar-sub-header"><a href="/dist/page-1/Class/#类的方法" class="sidebar-link">类的方法</a></li><li class="sidebar-sub-header"><a href="/dist/page-1/Class/#getter-和-setter" class="sidebar-link">getter 和 setter</a></li><li class="sidebar-sub-header"><a href="/dist/page-1/Class/#extends" class="sidebar-link">extends</a></li><li class="sidebar-sub-header"><a href="/dist/page-1/Class/#constructor-方法" class="sidebar-link">constructor 方法</a></li><li class="sidebar-sub-header"><a href="/dist/page-1/Class/#super-关键字" class="sidebar-link">super 关键字</a></li></ul></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>js杂项知识点</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>js设计模式</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>有待学习的</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>HTML</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>CSS</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>JS</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>VUE</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>HTTP</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>es6相关</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Git</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>webpack</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>英语单词</span> <span class="arrow right"></span></p> <!----></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h2 id="es6-class"><a href="#es6-class" class="header-anchor">#</a> es6 class</h2> <p>定义：
在ES6中，class (类)作为对象的模板被引入，可以通过 class 关键字定义类。 <br>
class 的本质是 function。<br>
它可以看作一个语法糖，让对象原型的写法更加清晰、更像面向对象编程的语法。<br></p> <h2 id="基础用法"><a href="#基础用法" class="header-anchor">#</a> 基础用法</h2> <p>在ES5时代，可以像下面这样模拟一个类，先声明一个构造函数，然后在其原型上定义共享的方法，最后与new运算符组合实例化一个类。</p> <div class="language- extra-class"><pre class="language-text"><code>function People(name) {
  this.name = name;
}
People.prototype.getName = function () {
  return this.name;
};
var people = new People(&quot;strick&quot;);
people.getName();       //&quot;strick&quot;
</code></pre></div><p>1.0 类的定义</p> <div class="language- extra-class"><pre class="language-text"><code>// 匿名类
let Example = class{
    constructor(a){
        this.a = a;
    }
}
// 命名类
let Example = class Example{
    constructor(a){
        this.a = a;
    }
}
</code></pre></div><p>2.0 类声明</p> <div class="language- extra-class"><pre class="language-text"><code>class Example{
    constructor(a){
        this.a = a;
    }
}
</code></pre></div><p>注意点： <br>
1.0 不能重复声明</p> <div class="language- extra-class"><pre class="language-text"><code>比如：
 class Example{}
 class Example{}
// Uncaught SyntaxError: Identifier 'Example' has already been 
// declared
再比如：
let Example1 = class{}
class Example{}
// Uncaught SyntaxError: Identifier 'Example' has already been 
// declared
</code></pre></div><p>2.0 类定义不能被提升 意味着必须在访问前对类进行定义，否则就会报错。<br>
类中方法不需要 function 关键字。<br>
方法间不能加分号。<br></p> <div class="language- extra-class"><pre class="language-text"><code>    class People{
        constructor(name){
            this.name = name   
        }
        getName(){
            return this.name
        }
    }
var people = new People('lie')
people.getName(); // lie
typeof People;// function
typeof People.prototype.getName;// function
</code></pre></div><h2 id="类的主体"><a href="#类的主体" class="header-anchor">#</a> 类的主体</h2> <p>属性
1.0 prototype 还是存在的，虽然可以直接自类中定义方法，但是其实方法还是定义在 prototype 上的。 覆盖方法 / 初始化时添加方法</p> <div class="language- extra-class"><pre class="language-text"><code>Example.prototype={
    //methods
}
添加方法
Object.assign(Example.prototype,{
    //methods
})
</code></pre></div><p>2.0 静态属性 <br>
Class 内部只有静态方法，没有静态属性。<br>
3.0 公共属性</p> <div class="language- extra-class"><pre class="language-text"><code>class Example{}
Example.prototype.a = 2;
</code></pre></div><p>4.0 实例属性</p> <div class="language- extra-class"><pre class="language-text"><code>实例属性：定义在实例对象（ this ）上的属性。

class Example {
    a = 2;
    constructor () {
        console.log(this.a);
    }
}
</code></pre></div><p>5.0 name 属性 <br>
返回跟在 class 后的类名(存在时)。</p> <div class="language- extra-class"><pre class="language-text"><code>   let Example=class Exam {
       constructor(a) {
           this.a = a;
       }
   }
   console.log(Example.name); // Exam
    
   let Example=class {
       constructor(a) {
           this.a = a;
       }
   }
   console.log(Example.name); // Example
</code></pre></div><h2 id="类的方法"><a href="#类的方法" class="header-anchor">#</a> 类的方法</h2> <p>1.0 constructor 方法 <br>
constructor 方法是类的默认方法，创建类的实例化对象时被调用。</p> <div class="language- extra-class"><pre class="language-text"><code>class Example{
    constructor(){
      console.log('我是constructor');
    }
}
new Example(); // 我是constructor
</code></pre></div><p>返回对象</p> <div class="language- extra-class"><pre class="language-text"><code>class Test {
    constructor(){
        // 默认返回实例对象 this
    }
}
console.log(new Test() instanceof Test); // true
 
class Example {
    constructor(){
        // 指定返回对象
        return new Test();
    }
}
console.log(new Example() instanceof Example); // false
</code></pre></div><p>2.0 静态方法</p> <div class="language- extra-class"><pre class="language-text"><code>class Example{
    static sum(a, b) {
        console.log(a+b);
    }
}
Example.sum(1, 2); // 3
</code></pre></div><p>3.0 原型方法</p> <div class="language- extra-class"><pre class="language-text"><code>class Example {
    sum(a, b) {
        console.log(a + b);
    }
}
let exam = new Example();
exam.sum(1, 2); // 3
</code></pre></div><p>4.0  实例方法 跟上面比实例化的时候就已经被创建了 (不用在意)</p> <div class="language- extra-class"><pre class="language-text"><code>class Example {
    constructor() {
        this.sum = (a, b) =&gt; {
            console.log(a + b);
        }
    }
}
let exam = new Example();
exam.sum(1, 2); // 3
</code></pre></div><p>类的实例化
new <br>
class 的实例化必须通过 new 关键字。<br></p> <div class="language- extra-class"><pre class="language-text"><code>class Example {}
let exam1 = Example();
// Class constructor Example cannot be invoked without 'new' 
</code></pre></div><p>实例化对象  共享原型对象</p> <div class="language- extra-class"><pre class="language-text"><code>class Example {
    constructor(a, b) {
        this.a = a;
        this.b = b;
        console.log('Example');
    }
    sum() {
        return this.a + this.b;
    }
}
let exam1 = new Example(2, 1);
let exam2 = new Example(3, 1);
console.log(exam1._proto_ == exam2._proto_); // true
 
exam1._proto_.sub = function() {
    return this.a - this.b;
}
console.log(exam1.sub()); // 1
console.log(exam2.sub()); // 2
</code></pre></div><h2 id="getter-和-setter"><a href="#getter-和-setter" class="header-anchor">#</a> getter 和 setter</h2> <p>例子：</p> <div class="language- extra-class"><pre class="language-text"><code>class Example{
    constructor(a, b) {
        this.a = a; // 实例化时调用 set 方法
        this.b = b;
    }
    get a(){
        console.log('getter');
        return this.a;
    }
    set a(a){
        console.log('setter');
        this.a = a; // 自身递归调用
    }
}
let exam = new Example(1,2); // 不断输出 setter ，最终导致 RangeError
</code></pre></div><p>另外一个例子：</p> <div class="language- extra-class"><pre class="language-text"><code>class Example1{
    constructor(a, b) {
        this.a = a;
        this.b = b;
    }
    get a(){
        console.log('getter');
        return this._a;
    }
    set a(a){
        console.log('setter');
        this._a = a;
    }
}
let exam1 = new Example1(1,2); // 只输出 setter , 不会调用 getter 方法
console.log(exam._a); // 1, 可以直接访问
</code></pre></div><p>getter 不能单独出现</p> <div class="language- extra-class"><pre class="language-text"><code>class Example {
    constructor(a) {
        this.a = a; 
    }
    get a() {
        return this.a;
    }
}
let exam = new Example(1); // Uncaught TypeError: Cannot set property // a of #&lt;Example&gt; which has only a getter
</code></pre></div><p>getter与setter必须同时出现</p> <div class="language- extra-class"><pre class="language-text"><code>class Father {
    constructor(){}
    get a() {
        return this._a;
    }
}
class Child extends Father {
    constructor(){
        super();
    }
    set a(a) {
        this._a = a;
    }
}
let test = new Child();
test.a = 2;
console.log(test.a); // undefined
console.log(test._a); // 2
Father.a //undefined
Father._a //undefined
</code></pre></div><p>都放在父类或者子类里面</p> <div class="language- extra-class"><pre class="language-text"><code>class Father1 {
    constructor(){}
    // 或者都放在子类中
    get a() {
        return this._a;
    }
    set a(a) {
        this._a = a;
    }
}
class Child1 extends Father1 {
    constructor(){
        super();
    }
}
let test1 = new Child1();
test1.a = 2;
console.log(test1.a); // 2
</code></pre></div><h2 id="extends"><a href="#extends" class="header-anchor">#</a> extends</h2> <p>通过exteds实现类的继承<br>
super <br>
子类constructor方法中必须有super，且必须出现在this之前。</p> <div class="language- extra-class"><pre class="language-text"><code>class Father {
    constructor() {}
}
class Child extends Father {
    constructor() {}
    // or 
    // constructor(a) {
        // this.a = a;
        // super();
    // }
}
let test = new Child(); // Uncaught ReferenceError: Must call super 
// constructor in derived class before accessing 'this' or returning 
// from derived constructor
</code></pre></div><p>调用父类构造函数,只能出现在子类的构造函数。</p> <div class="language- extra-class"><pre class="language-text"><code>class Father {
    test(){
        return 0;
    }
    static test1(){
        return 1;
    }
}
class Child extends Father {
    constructor(){
        super();
    }
}
class Child1 extends Father {
    test2() {
        super(); // Uncaught SyntaxError: 'super' keyword unexpected     
        // here
    }
}
</code></pre></div><p>调用父类方法, super 作为对象，在普通方法中，指向父类的原型对象，在静态方法中，指向父类</p> <div class="language- extra-class"><pre class="language-text"><code>class Child2 extends Father {
    constructor(){
        super();
        // 调用父类普通方法
        console.log(super.test()); // 0
    }
    static test3(){
        // 调用父类静态方法
        return super.test1()+2;
    }
}
Child2.test3(); // 3
</code></pre></div><h2 id="constructor-方法"><a href="#constructor-方法" class="header-anchor">#</a> constructor 方法</h2> <p>constructor 方法是类的构造函数，是一个默认方法，通过 new 命令创建对象实例时，自动调用该方法。一个类必须有 constructor 方法，如果没有显式定义，一个默认的 consructor 方法会被默认添加。所以即使你没有添加构造函数，也是会有一个默认的构造函数的。一般 constructor 方法返回实例对象 this ，但是也可以指定 constructor 方法返回一个全新的对象，让返回的实例对象不是该类的实例。</p> <div class="language- extra-class"><pre class="language-text"><code>es5
function Point(x, y) {
  this.x = x;
  this.y = y;
}
 
Point.prototype.toString = function() {
  return '(' + this.x + ',' + this.y + ')';
}
</code></pre></div><p>等同于</p> <div class="language- extra-class"><pre class="language-text"><code>
class Point {
  constructor(x, y) {
    this.x = x;
    this.y = y;
  }
 
  toString() {
    return '(' + this.x + ',' + this.y + ')';
  }
}
</code></pre></div><h2 id="super-关键字"><a href="#super-关键字" class="header-anchor">#</a> super 关键字</h2> <p>super 这个关键字，既可以当做函数使用，也可以当做对象使用。这两种情况下，它的用法完全不用。<br>
1.0 当做函数使用</p> <div class="language- extra-class"><pre class="language-text"><code>class A {}
class B extends A {
  constructor() {
    super();  // ES6 要求，子类的构造函数必须执行一次 super 函数，否则会报错。
  }
}
</code></pre></div><p>注意：在 constructor 中必须调用 super 方法，因为子类没有自己的 this 对象，而是继承父类的 this 对象，然后对其进行加工,而 super 就代表了父类的构造函数。super 虽然代表了父类 A 的构造函数，但是返回的是子类 B 的实例，即 super 内部的 this 指的是 B，因此 super() 在这里相当于 ```A.prototype.constructor.call(this, props)``。</p> <div class="language- extra-class"><pre class="language-text"><code>class A {
  constructor() {
    console.log(new.target.name); // new.target 指向当前正在执行的函数
  }
}
 
class B extends A {
  constructor {
    super();
  }
}
 
new A(); // A
new B(); // B
</code></pre></div><p>可以看到，在 super() 执行时，它指向的是 子类 B 的构造函数，而不是父类 A 的构造函数。也就是说，super() 内部的 this 指向的是 B。
<br>
2.0 当做对象使用
<br>
在普通方法中，指向父类的原型对象；在静态方法中，指向父类。</p> <div class="language- extra-class"><pre class="language-text"><code>lass A {
  c() {
    return 2;
  }
}
 
class B extends A {
  constructor() {
    super();
    console.log(super.c()); // 2
  }
}
 
let b = new B();
</code></pre></div><p>上面代码中，子类 B 当中的 super.c()，就是将 super 当作一个对象使用。这时，super 在普通方法之中，指向 A.prototype，所以 super.c() 就相当于 A.prototype.c()。
<br>
通过 super 调用父类的方法时，super 会绑定子类的 this。</p> <div class="language- extra-class"><pre class="language-text"><code>class A {
  constructor(){
    this.x = 1;
  }
  s() {
    console.log(this.x);
  }
}
 
class B extends A {
  constructor(){
    super();
    this.x = 2;
  }
  m() {
    super.s();
  }
}
 
let b = new B();
b.m(); // 2
</code></pre></div><p>上面代码中，super.s() 虽然调用的是 A.prototytpe.s()，但是 A.prototytpe.s()会绑定子类 B 的 this，导致输出的是 2，而不是 1。也就是说，实际上执行的是 super.s.call(this)。
<br></p> <p>由于绑定子类的 this，所以如果通过 super 对某个属性赋值，这时 super 就是 this，赋值的属性会变成子类实例的属性</p> <div class="language- extra-class"><pre class="language-text"><code>class A {
  constructor() {
    this.x = 1;
  }
}
 
class B extends A {
  constructor() {
    super();
    this.x = 2;
    super.x = 3;
    console.log(super.x); // undefined
    console.log(this.x); // 3
  }
}
 
let b = new B();

</code></pre></div><p>上面代码中，super.x 赋值为 3，这时等同于对 this.x 赋值为 3。而当读取 super.x 的时候，调用的是 A.prototype.x，但并没有 x 方法，所以返回 undefined。</p> <p>注意，使用 super 的时候，必须显式指定是作为函数，还是作为对象使用，否则会报错。<br></p> <div class="language- extra-class"><pre class="language-text"><code>比如上面的例子
class B extends A {
  constructor() {
    super();
    console.log(super); // Uncaught SyntaxError: 'super' keyword unexpected here
    console.log(super()); // Super constructor may only be called once
  }
}
class B extends A {
  constructor() {
    console.log(super());// 这样是不报错的 如果
  }
}
</code></pre></div><p>上面代码中，console.log(super); 的当中的 super，无法看出是作为函数使用，还是作为对象使用，所以 JavaScript 引擎解析代码的时候就会报错。这是，如果能清晰的表明 super 的数据类型，就不会报错。
<br></p> <p>super 虽然代表了父类 A 的构造函数，但是返回的是子类 B 的实例，即 super 内部的 this 指的是 B，因此 super() 在这里相当于 ```A.prototype.constructor.call(this, props)``。
<br>
如下：</p> <div class="language- extra-class"><pre class="language-text"><code>class A {
  constructor() {
    this.x = 1;
  }
}
 
class B extends A {
  constructor() {
    console.log(super()) // B {x: 1}
    this.x = 2;
    super.x = 3;
    
    console.log(this.x); // 3
  }
}
 
let b = new B();

</code></pre></div><p>最后，由于对象总是继承其他对象的，所以可以在任意一个对象中，使用 super 关键字。</p></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/dist/page-1/Global/" class="prev">
        js 全局
      </a></span> <span class="next"><a href="/dist/page-2/one/">
        DOM 事件机制
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/dist/assets/js/app.c917e6cc.js" defer></script><script src="/dist/assets/js/2.47087845.js" defer></script><script src="/dist/assets/js/10.272a0d8f.js" defer></script>
  </body>
</html>
