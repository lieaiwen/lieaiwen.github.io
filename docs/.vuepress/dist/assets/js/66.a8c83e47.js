(window.webpackJsonp=window.webpackJsonp||[]).push([[66],{284:function(n,e,t){"use strict";t.r(e);var s=t(6),r=Object(s.a)({},(function(){var n=this,e=n.$createElement,t=n._self._c||e;return t("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[t("h2",{attrs:{id:"代理模式-proxy（代理）"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#代理模式-proxy（代理）"}},[n._v("#")]),n._v(" 代理模式 Proxy（代理）")]),n._v(" "),t("p",[n._v("代理模式是为一个对象提供一个代用品或占位符，以便控制对它的访问。"),t("br"),n._v("\n比如 明星有经纪人，如果想请明星来办一场活动，只能联系他的经纪人，\n经纪人会把报酬和活动细节谈好后 ，把合同交给明星。")]),n._v(" "),t("br"),n._v("\n本例举一个用代理对象加载图片的例子来理解代理模式，当网络不好的时候，图片的\n加载需要一段时间，这就会产生空白，影响用户体验，这时候我们可在图片真正加载完\n之前，使用一张loading站位图片，等图片真正加载完再给图片设置src属性。\n"),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("class MyImage {\n    constructor() {\n        this.img = new Image()\n        document.body.appendChild(this.img)\n    }\n    setSrc(src) { // 这是个方法 不是setter 属性\n        this.img.src = src\n    }\n}\n\nclass ProxyImage {\n    constructor() {\n        this.proxyImage = new Image()\n    }\n\n    setSrc(src) { // 这是个方法 不是setter 属性\n        let myImageObj = new MyImage()\n        myImageObj.img.src = 'file://xxx.png'  //为本地图片url\n        this.proxyImage.src = src\n        this.proxyImage.onload = function() {\n            myImageObj.img.src = src\n        }\n    }\n}\n\nvar proxyImage = new ProxyImage()\nproxyImage.setSrc('http://xxx.png') //服务器资源url\n")])])]),t("p",[n._v("上面 本体类中有自己的setSrc 方法，如果有一天网络速度不再需要 预加载了，我们\n可以直接使用本体的setSrc，并且不需要改动本体类的代码，而且可以删除代理类")]),n._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[n._v("// 依旧可以满足需求\nvar myImage = new MyImage()\nmyImage.setSrc('http://qiniu.sunzhaoye.com/CORS.png')\n")])])]),t("p",[n._v("小结"),t("br"),n._v("\n1.0 代理模式符合开放闭合原则\n2.0 本体对象和代理对象拥有相同的方法，在用户看来并不知道请求的本体对象还是代理对象。")])])}),[],!1,null,null,null);e.default=r.exports}}]);