(window.webpackJsonp=window.webpackJsonp||[]).push([[74],{293:function(e,n,t){"use strict";t.r(n);var o=t(6),a=Object(o.a)({},(function(){var e=this,n=e.$createElement,t=e._self._c||n;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("h2",{attrs:{id:"一道js题"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#一道js题"}},[e._v("#")]),e._v(" 一道js题")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("function Foo() {\n  getName = function() { console.log(1) } // 没有用关键字 var 所以定义的是全局的\n  return this // 这里返回的是window \n}\n\nFoo.getName = function() { console.log(2) }\nFoo.prototype.getName = function() { console.log(3) }\n\nvar getName = function() { console.log(4) }\nfunction getName () { console.log(5)  }\n\n写出下面代码，打印的内容\nFoo.getName()\ngetName()\nFoo().getName()\ngetName()\nnew Foo.getName()\nnew Foo().getName()\n")])])]),t("p",[e._v("先回顾一下函数的3 种声明方式")]),e._v(" "),t("h3",{attrs:{id:"_1-0-函数声明"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-0-函数声明"}},[e._v("#")]),e._v(" 1.0 函数声明")]),e._v(" "),t("p",[e._v("这种方式就是使用 function 声明一个具名函数，特点是可以先使用后声明")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("fn()    // hello world!\nfunction fn() {\n\tconsole.log('hello world!')\n}\n")])])]),t("h3",{attrs:{id:"_2-0-函数表达式"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-0-函数表达式"}},[e._v("#")]),e._v(" 2.0 函数表达式")]),e._v(" "),t("p",[e._v("这种方式是把一个匿名函数赋给一个变量，必须先声明后使用")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("let fn1 = function(){\n\tconsole.log('hello world!')\n}\nfn1()   // hello world!\n\nfn2()   // Uncaught ReferenceError: Cannot access 'fn2' before initialization\nlet fn2 = function(){\n\tconsole.log('hello world!')\n}\n")])])]),t("h3",{attrs:{id:"_3-0-通过构造函数-new-生成"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-0-通过构造函数-new-生成"}},[e._v("#")]),e._v(" 3.0 通过构造函数 new 生成")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("//  let 函数名 = new Function(“参数...”, ”函数体”)\nlet fn = new Function('a', 'b', 'return a +b')\nfn(1, 2)    // 3\n")])])]),t("p",[e._v("解析："),t("br"),e._v("\n1.0 Foo.getName() // 打印2\n"),t("br"),e._v("\n2.0 getName() //4 这里有个概念就是函数声明会被提升，所以等于 现有了 function getName () { console.log(5)  }，然后再\n重新定义了getName，所以打印4\n"),t("br"),e._v("\n3.0 Foo().getName() //1 Foo函数的返回值是this,所以Foo().getName()就是window.getName(),Foo()函数内全局的getName被覆盖，所以Foo().getName()执行后，打印1。\n"),t("br"),e._v("\n4.0 getName() // 1 上面Foo()函数执行 getName变成全局的\n"),t("br"),e._v("\n5.0 new Foo.getName() //2  因为：. 的优先级比 new 高，所以这里就是一次 Foo.getName() 调用，所以是 2 ,new 是误导用的\n"),t("br"),e._v("\n6.0 new Foo().getName() //3 new Foo() 加个括号，是提升了优先级，会去先执行 new Foo(), 然后在调用 .getName(), 那问题又来了，为啥不是 1，因为内部的 getName 不是绑定在 this 上的呀，所以就去找原型上的方法，结果是 3")])])}),[],!1,null,null,null);n.default=a.exports}}]);