(window.webpackJsonp=window.webpackJsonp||[]).push([[67],{255:function(n,t,s){"use strict";s.r(t);var e=s(6),o=Object(e.a)({},(function(){var n=this,t=n.$createElement,s=n._self._c||t;return s("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[s("h2",{attrs:{id:"js-this-指向问题"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#js-this-指向问题"}},[n._v("#")]),n._v(" js this 指向问题")]),n._v(" "),s("blockquote",[s("p",[n._v("this 就是一个指针，指向调用函数的对象")])]),n._v(" "),s("ol",[s("li",[n._v("单独的this，指向的是window这个对象 (默认绑定)")])]),n._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[n._v(" console.log(this) // window\n")])])]),s("ol",{attrs:{start:"2"}},[s("li",[n._v("全局函数中的this (默认绑定)")])]),n._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[n._v(" function foo(){\n     console.log(this) // window\n }\n foo()\n\n严格模式下,this->undefined\n    function foo(){\n        'use strict'\n        console.log(this)\n    }\n    foo()\n")])])]),s("ol",{attrs:{start:"3"}},[s("li",[n._v("通过new 关键字生成的对象 this就指向该对象")])]),n._v(" "),s("blockquote",[s("p",[n._v("所谓构造函数，就是通过这个函数生成一个新对象，这时，this就指向这个对象。")])]),n._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[n._v('function foo(){\n    this.name = "big"\n    console.log(this) // foo {name: "big"}\n}\nvar a = new foo()\nconsole.log(a) // foo {name: "big"}\nconsole.log(a.name) // big\n')])])]),s("ol",{attrs:{start:"4"}},[s("li",[n._v("用call与apply的方式调用函数")])]),n._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[n._v("function demo() {\n    console.log(this);\n}\ndemo.call('abc'); // abc\ndemo.call(null); // this -> window\ndemo.call(undefined); // this -> window \n")])])]),s("ol",{attrs:{start:"5"}},[s("li",[n._v("定时器中的this，指向的是window")])]),n._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[n._v("setTimeout(function() {\n        console.log(this); // this -> window ，严格模式 也是指向window\n    },500) \n")])])]),s("ol",{attrs:{start:"6"}},[s("li",[n._v("元素绑定事件，事件触发后，执行的函数中的this，指向的是当前元素")])]),n._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[n._v(" let $btn = document.getElementById('btn');\n $btn.onclick = function(){\n     console.log(this); // this -> 当前元素\n }\n")])])]),s("ol",{attrs:{start:"7"}},[s("li",[n._v("函数调用时如果绑定了bind，那么函数中的this指向了bind中绑定的元素")])]),n._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[n._v(" let $btn = document.getElementById('btn');\n $btn.addEventListener('click',function() {\n    console.log(this); // window\n }.bind(window)) \n")])])]),s("ol",{attrs:{start:"8"}},[s("li",[n._v("对象中的方法，该方法被哪个对象调用了，那么方法中的this就指向该对象 (隐式绑定)")])]),n._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[n._v(" let name = 'out'\n     let obj = {\n         name: 'in',\n         getName: function() {\n             console.log(this.name);\n         }\n     }\n     obj.getName(); // in\n     let fn = obj.getName; // 等于 let fn = function(){}\n     fn(); //out  this -> window\n")])])]),s("ol",{attrs:{start:"9"}},[s("li",[n._v("箭头函数是ES6中新增的，它和普通函数有一些区别，箭头函数没有自己的this，它的this继承于外层代码库中的this")])]),n._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[n._v("var obj = {\n        hi: function(){\n            console.log(this);\n            return ()=>{\n                console.log(this);\n            }\n        },\n        sayHi: function(){\n            return function() {\n                console.log(this);\n                return ()=>{\n                    console.log(this);\n                }\n            }\n        },\n        say: ()=>{\n            console.log(this);\n        }\n    }\n    let hi = obj.hi();  // obj 对象上的函数 function(){ console.log(this); return ()=> { console.log(this) } },\n    hi();               // obj\n    let sayHi = obj.sayHi();  // 独立的函数 function() { console.log(this); return ()=>{console.log(this);}\n    let fun1 = sayHi(); // window return ()=>{console.log(this)}\n    fun1();             //  window\n    obj.say();          // window 对象上的箭头函数指向 外层 window \n")])])]),s("p",[s("strong",[n._v("如何判定 this的指向的是什么")])]),n._v(" "),s("ol",[s("li",[n._v("函数是否在new中调用(new绑定)，如果是，那么this绑定的是新创建的对象。")]),n._v(" "),s("li",[n._v("函数是否通过call,apply调用，或者使用了bind(即硬绑定)，如果是，那么this绑定的就是指定的对象。")]),n._v(" "),s("li",[n._v("函数是否在某个上下文对象中调用(隐式绑定)，如果是的话，this绑定的是那个上下文对象。一般是obj.foo()")]),n._v(" "),s("li",[n._v("如果以上都不是，那么使用默认绑定。如果在严格模式下，则绑定到undefined，否则绑定到全局对象。")]),n._v(" "),s("li",[n._v("如果把null或者undefined作为this的绑定对象传入call、apply或者bind，这些值在调用时会被忽略，实际应用的是默认绑定规则。")]),n._v(" "),s("li",[n._v("如果是箭头函数，箭头函数的this继承的是外层代码块的this。")])]),n._v(" "),s("p",[s("strong",[n._v("来做一道题")])]),n._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[n._v(" var x = 10;\n     var a = {\n         x: 20,\n         fn: function() {\n             var x = 30\n             return function() {\n                 return this.x;\n             }\n         }\n     }\n     console.log( a.fn() ) // function(){ return this.x }\n     console.log( (a.fn())() ) // this->window.x->10\n     console.log( a.fn()() ) // this->window.x->10\n     console.log( (a.fn())() == a.fn()() ) // true\n     console.log( a.fn().call(this) ) // this->window.x->10\n     console.log( a.fn().call(a) ) // this->a->20\n")])])]),s("p",[s("strong",[n._v("再来一道")])]),n._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[n._v("var number = 5;\nvar obj = {\n    number: 3,\n    fn1: (function () {\n        var number;\n        this.number *= 2;\n        number = number * 2;\n        number = 3;\n        return function () {\n            var num = this.number;\n            this.number *= 2;\n            console.log(num);\n            number *= 3;\n            console.log(number);\n        }\n    })()\n}\nvar fn1 = obj.fn1;\nfn1.call(null);\nobj.fn1();\nconsole.log(window.number);\n")])])]),s("blockquote",[s("p",[n._v("var fn1 = obj.fn1")])]),n._v(" "),s("div",{staticClass:"language- extra-class"},[s("pre",{pre:!0,attrs:{class:"language-text"}},[s("code",[n._v("1.0 fn1 \n function(){\n  var num = this.number;\n  this.number *= 2;\n  console.log(num);\n  number *= 3;\n  console.log(number);\n }\n\n2.0  fn1.call(null); 改变fn1的this指向window，所以\n    先执行闭包  this.number = 10  number = 3\n    var num = 10\n    this.number = 20\n    num // 10\n    number = 闭包里面的3*3 9\n    则结果为  10 9\n\n3.0 obj.fn1() 对象调用 this指向 obj\n    这时候还是不执行闭包了\n    var num = 3\n    this.number = 6\n    num // 3\n    number = 闭包里面的9*3 27\n    则结果为  3 27\n\n4.0 上面 最后一步指向window的是 2.0 里面的 this.number 则\n    结果为：20\n")])])]),s("p",[n._v("参考链接："),s("a",{attrs:{href:""}},[n._v("FinGet")]),n._v(" https://www.jb51.net/article/151599.htm"),s("br"),n._v("\n参考链接："),s("a",{attrs:{href:""}},[n._v("刘小夕的博客")]),n._v(" https://juejin.im/post/5c96d0c751882511c832ff7b#heading-3")])])}),[],!1,null,null,null);t.default=o.exports}}]);