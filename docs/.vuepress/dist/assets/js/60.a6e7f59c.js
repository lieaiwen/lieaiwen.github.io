(window.webpackJsonp=window.webpackJsonp||[]).push([[60],{279:function(e,n,t){"use strict";t.r(n);var r=t(6),o=Object(r.a)({},(function(){var e=this,n=e.$createElement,t=e._self._c||n;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("h2",{attrs:{id:"装饰器模式"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#装饰器模式"}},[e._v("#")]),e._v(" 装饰器模式")]),e._v(" "),t("p",[e._v("装饰者(decorator)模式能够在不改变对象自身的基础上，动态的给某个对象添加额外的职责，不会影响原有接口的功能。\n"),t("br"),e._v("\n模拟传统面向对象语言的装饰者模式")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("//原始的飞机类\nvar Plane = function () {\n};\n\nPlane.prototype.fire = function () {\n    console.log('发射普通子弹');\n};\n\n\n//装饰类\nvar MissileDecorator = function (plane) {\n    this.plane = plane;\n}\n\nMissileDecorator.prototype.fire = function () {\n    this.plane.fire();\n    console.log('发射导弹!');\n};\n\nvar plane = new Plane();\nplane = new MissileDecorator(plane);\nplane.fire();\n")])])]),t("p",[e._v("JavaScript中的装饰器模式")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("var Plane = {\n        fire:function(){\n            console.log('发射普通的子弹');\n        }\n    }\n    var oneDecorator = function(){\n        console.log('发射导弹!');\n    }\n    var fire = Plane.fire;\n    Plane.fire = function(){\n        fire();\n        oneDecorator()\n    }\n    Plane.fire();\n")])])]),t("p",[t("a",{attrs:{href:"https://www.cnblogs.com/gaosirs/p/10756503.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("参考"),t("OutboundLink")],1),t("br"),e._v("\n复杂一点的")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("// 装饰者模式 decorate(装饰)\nvar tree = {};\ntree.decorate = function(){\n\tconsole.log('别让树倒了')\n}\n// Decorator(装饰器) 定义方法，用于添加额外的装饰器，\n// 装饰器被实现为构造器函数 都继承自tree对象\ntree.getDecorator = function(deco){\n\ttree[deco].prototype = this\n\treturn new tree[deco];\n}\n// 创建装饰器 redBalls() ,我们将他设为tree的一个属性(已保持\n//全局命名空间的纯净) ，redBall 对象也提供了decorate()方法，\n// 注意它先调用了父类的decorate()方法\n\ntree.RedBalls = function(){\n\tthis.decorate = function (){\n\t\tthis.RedBalls.prototype.decorate();\n\t\tconsole.log('放一些红球')\n\t}\n}\ntree.BlueBalls = function(){\n\tthis.decorate = function (){\n\t\tthis.BlueBalls.prototype.decorate();\n\t\tconsole.log('放一些蓝球1')\n\t}\n}\ntree.caidai = function(){\n\tthis.decorate = function (){\n\t\tthis.caidai.prototype.decorate();\n\t\tconsole.log('放一些彩带')\n\t}\n}\n\n// 再把所有的装饰器都添加到基础对象中\ntree = tree.getDecorator('BlueBalls');\ntree = tree.getDecorator('RedBalls');\ntree = tree.getDecorator('caidai');\ntree.decorate();\n// 返回的顺序是这个哦\n/*别让树倒了\n 放一些蓝球1\n 放一些红球\n 放一些彩带*/\n")])])])])}),[],!1,null,null,null);n.default=o.exports}}]);