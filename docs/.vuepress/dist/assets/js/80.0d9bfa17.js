(window.webpackJsonp=window.webpackJsonp||[]).push([[80],{295:function(n,r,a){"use strict";a.r(r);var e=a(6),o=Object(e.a)({},(function(){var n=this,r=n.$createElement,a=n._self._c||r;return a("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[a("h2",{attrs:{id:"js-深浅拷贝"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#js-深浅拷贝"}},[n._v("#")]),n._v(" js 深浅拷贝")]),n._v(" "),a("p",[a("strong",[n._v("数组的浅拷贝")])]),n._v(" "),a("blockquote",[a("p",[n._v("可以利用数组的一些方法比如:slice、concat返回一个新数组的特性来实现拷贝")])]),n._v(" "),a("ol",[a("li",[n._v("concat")])]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v(" var arr = ['abc',1,true,null,undefined]\n var new_arr = arr.concat();\n new_arr[0] = 'aaa';\n console.log(arr) // ['abc',1,true,null,undefined]\n console.log(new_arr) // ['aaa',1,true,null,undefined]\n")])])]),a("ol",{attrs:{start:"2"}},[a("li",[n._v("slice")])]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v(" var arr = ['abc',1,true,null,undefined]\n var new_arr = arr.slice();\n new_arr[0] = 'aaa';\n console.log(arr) // ['abc',1,true,null,undefined]\n console.log(new_arr) // ['aaa',1,true,null,undefined]\n")])])]),a("p",[n._v("但是假设我们数组里面嵌套了对象或者数组的话,就会出现不一样的结果")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v(" var arr = [{name:'xiao'}, [1]]\n var new_arr = arr.concat();\n new_arr[0].name = 'big';\n arr[1][0] = 2;\n console.log(arr) // [{name:'big'}, [2]]\n console.log(new_arr) // [{name:'big'}, [2]]\n")])])]),a("p",[n._v("上面的例子我们，不管是新数组还是旧数组都发生了变化，\n也就是说concat方法，克隆的并不彻底。"),a("br")]),n._v(" "),a("p",[n._v("如果数组元素是基本类型，就会拷贝一份，互不影响，但是如果是\n对象数组这样的引用类型的时候拷贝的就是其引用，这样无论在新旧数组进行了修改\n两者都会发生改变。"),a("br"),n._v("\n我们把这种复制引用的拷贝方法称之为浅拷贝，与之对应的就是深拷贝，深拷贝就是指完全的拷贝一个对象，即使嵌套了对象，两者也相互分离，修改一个对象的属性，也不会影响另一个。"),a("br"),n._v(" "),a("strong",[n._v("数组的深拷贝")])]),n._v(" "),a("p",[n._v("大多数情况下我们是可以使用这个技巧的，如下：")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v(" var arr = [{name:'xiao'}, [1]]\n var new_arr = JSON.parse(JSON.stringify(arr));\n new_arr[0].name = 'big';\n arr[1][0] = 2;\n console.log(arr) //[{name:'xiao'}, [2]]\n console.log(new_arr)//[{name:'big'}, [1]]\n")])])]),a("p",[n._v("但也有一个问题，就是不能拷贝函数，")]),n._v(" "),a("blockquote",[a("p",[n._v("PS:一般到这里就差不多了,工作中我反正99.99%没见过 数组里面有函数的（目光短浅了）")])]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v(" var arr = [{b:function(){ console.log(2) }}, function(){ console.log(1) }]\n var new_arr = JSON.parse(JSON.stringify(arr));\n \n console.log(new_arr)//[{}, null]\n")])])]),a("p",[a("strong",[n._v("浅拷贝的实现")])]),n._v(" "),a("p",[n._v("上面的 concat、slice 、 JSON.stringify()都属于技巧类的，\n那我们怎么实现一个数组或者对象的浅拷贝呢？"),a("br")]),n._v(" "),a("p",[n._v("好好想想，那就遍历对象，然后把属性和属性值放在一个新的对象好像就可以了")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("var arr = [1,{b:function(){ console.log(2) }}, function(){ console.log(1) },[5,6]]\nvar shallowCopy = function(obj) {\n    // 只拷贝对象\n    if (typeof obj !== 'object') return;\n    // 根据obj的类型判断是新建一个数组还是对象\n    var newObj = obj instanceof Array ? [] : {};\n    // 遍历obj，并且判断是obj的属性才拷贝\n    for (var key in obj) {\n        if (obj.hasOwnProperty(key)) {\n            newObj[key] = obj[key];\n        }\n    }\n    return newObj;\n}\nlet new_arr = shallowCopy(arr)\nnew_arr[1].b() // 2 证明浅拷贝成功 包括函数\nnew_arr[0] // 1\narr[3][1]=111\nconsole.log(new_arr[3][1]) //1111\n")])])]),a("p",[n._v("注意：我们上面的浅拷贝方法 已经实现了基本类型 和 function"),a("br")]),n._v(" "),a("p",[a("strong",[n._v("深拷贝的实现")])]),n._v(" "),a("p",[n._v("如何实现一个深拷贝呢？那现在不就里面还是一个对象或者数组，我们再一次调用深拷贝函数就可以了")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v(" var arr = [1,{b:function(){ console.log(2) }}, function(){ console.log(1) },[5,6]]\n var deepCopy = function(obj) {\n     // 只拷贝对象\n     if (typeof obj !== 'object') return;\n     // 根据obj的类型判断是新建一个数组还是对象\n     var newObj = obj instanceof Array ? [] : {};\n     // 遍历obj，并且判断是obj的属性才拷贝\n     for (var key in obj) {\n         if (obj.hasOwnProperty(key)) {\n             newObj[key] = typeof obj[key] !== 'object'? obj[key] : deepCopy(obj[key]);\n         }\n     }\n     return newObj;\n }\n let new_arr = deepCopy(arr)\n arr[3][1]=111\n console.log(new_arr[3][1]) //6  证明深拷贝成功\n")])])]),a("p",[n._v("参考链接："),a("a",{attrs:{href:"https://github.com/mqyqingfeng/Blog/issues/32",target:"_blank",rel:"noopener noreferrer"}},[n._v("冴羽的博客"),a("OutboundLink")],1)])])}),[],!1,null,null,null);r.default=o.exports}}]);