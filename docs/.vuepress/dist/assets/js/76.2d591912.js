(window.webpackJsonp=window.webpackJsonp||[]).push([[76],{291:function(n,a,e){"use strict";e.r(a);var r=e(6),t=Object(r.a)({},(function(){var n=this,a=n.$createElement,e=n._self._c||a;return e("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[e("h2",{attrs:{id:"js-2面试题-基础知识点"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#js-2面试题-基础知识点"}},[n._v("#")]),n._v(" js-2面试题+基础知识点")]),n._v(" "),e("h2",{attrs:{id:"_1-0-执行上下文栈"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_1-0-执行上下文栈"}},[n._v("#")]),n._v(" 1.0 执行上下文栈")]),n._v(" "),e("blockquote",[e("p",[n._v("当执行一个函数的时候，就会创建一个执行上下文，并且压入执行上下文栈，当函数执行完毕的时候，就会将函数的执行上下文从栈中弹出。")])]),n._v(" "),e("ul",[e("li",[n._v("变量对象")]),n._v(" "),e("li",[n._v("作用域链")]),n._v(" "),e("li",[n._v("this")])]),n._v(" "),e("h2",{attrs:{id:"_3-0-js-数据类型"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_3-0-js-数据类型"}},[n._v("#")]),n._v(" 3.0 js 数据类型")]),n._v(" "),e("p",[n._v("6种数据类型")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("1.0 string \n2.0 number \n3.0 boolean\n4.0 undefined\n5.0 null\n6.0 object\n7.0 Symble\n什么是symbol？ Symbol是ES6中新增的一种数据类型, 被划分到了基本数据类型中\nSymbol的作用：用来表示一个独一无二的值\n")])])]),e("p",[n._v("基本数据类型")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("string number null boolean undefined Symble\n")])])]),e("p",[n._v("引用数据类型")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("object array function\n\n二者区别\n1.0 基本数据类型就是简单的操作值\n2.0 引用数据类型就是把引用地址赋值给变量\n")])])]),e("h2",{attrs:{id:"_4-0-栈内存和堆内存的定义"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_4-0-栈内存和堆内存的定义"}},[n._v("#")]),n._v(" 4.0 栈内存和堆内存的定义")]),n._v(" "),e("p",[n._v("4.1 函数执行的时候首先会开辟一个新的内存空间叫栈内存（环境或作用域）")]),n._v(" "),e("p",[n._v("4.2 数据类型在赋值的时候会开辟一个新的内存空间叫堆内存（存放代码块）")]),n._v(" "),e("h2",{attrs:{id:"_5-0-object-create"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_5-0-object-create"}},[n._v("#")]),n._v(" 5.0 Object.create()")]),n._v(" "),e("p",[n._v("Object.create()方法创建一个新对象，使用现有的对象来提供新创建的对象的__proto__。\n"),e("br"),n._v("\n语法：Object.create(proto[, propertiesObject])")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v('demo1\nconst person = {\n  isHuman: false,\n  printIntroduction: function () {\n    console.log(`My name is ${this.name}. Am I human? ${this.isHuman}`);\n  }\n};\n\nconst me = Object.create(person);\n\nme.name = "Matthew"; // "name" is a property set on "me", but not on "person"\nme.isHuman = true; // inherited properties can be overwritten\n\nme.printIntroduction();\n// expected output: "My name is Matthew. Am I human? true"\n\nconsole.log(me) //\n   name: "Matthew"\n   isHuman: true\n    __proto__:\n        isHuman: false\n        printIntroduction: ƒ ()\n        __proto__: Object\n\ndemo2\nvar prototype = {\n    name: \'Jack\',\n    getName: function() {\n        return this.name\n    }\n}\n\nvar obj = Object.create(prototype, {\n    job: {\n        value: \'IT\'\n    }\n})\n\nconsole.log(obj.getName())  // Jack\nconsole.log(obj.job)  // IT\nconsole.log(obj.__proto__ === prototype)  //true\nconsole.log(obj) \n    job: "IT"\n    __proto__:\n        name: "Jack"\n        getName: ƒ ()\n        __proto__: Object\n\n')])])]),e("h2",{attrs:{id:"_8-0-js获取程序执行的时间"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_8-0-js获取程序执行的时间"}},[n._v("#")]),n._v(" 8.0 js获取程序执行的时间")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("方法一\n    console.time('global')\n    //要执行的代码放中间\n    console.timeEnd('global')\n    global是标志这两个time是一对的。\n方法二：\n    // 起始时间\n    let start = Date.now(); \n    // 调用函数\n    doSomething(); \n    // 结束时间\n    let stop = Date.now(), \n    result = stop - start;\n")])])]),e("h2",{attrs:{id:"_9-0-把一个字符串转换为驼峰命名"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_9-0-把一个字符串转换为驼峰命名"}},[n._v("#")]),n._v(" 9.0 把一个字符串转换为驼峰命名")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("function toString(foo){\n        var arr = foo.split('-');\n        for(var i=1;i < arr.length;i++){\n            arr[i] = arr[i].charAt(0).toUpperCase() + arr[i].substr(1,arr[i].length-1)\n\n        }\n        return arr.join('')\n    }\n    toString('get-element-by-id'); \n")])])]),e("h2",{attrs:{id:"_10-0-一个有意思的面试题"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_10-0-一个有意思的面试题"}},[n._v("#")]),n._v(" 10.0 一个有意思的面试题")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("function Foo(){\n        getName = function (){console.log(1)}\n        return this;\n    }\n    Foo.getName = function(){console.log(2)}\n    Foo.prototype.getName = function(){console.log(3)}\n    var getName = function(){console.log(4)}\n    function getName(){console.log(5)}\n\n    Foo.getName(); //2\n    getName(); //4 \n    Foo().getName(); //1\n    getName(); //1\n    new Foo.getName(); // new (Foo.getName)() // new (function(){console.log(2)}) //2\n    new Foo().getName(); // (new Foo()).getName() 实例对象先从自身找 自身原型链 Object 外层 //3\n    new new Foo.getName(); // new ((new Foo()).getName)() // new (foo.getName)() // 3\n\n其实上面的 代码可以这样写 \n1.0变量的提升和函数的提上\n2.0 当函数名和变量名 重名的时候保留函数\n\nfunction Foo(){\n        getName = function (){console.log(1)}\n        return this;\n    }\n    var getName;\n    function getName(){console.log(5)}\n    Foo.getName = function(){console.log(2)}\n    Foo.prototype.getName = function(){console.log(3)}\n    getName = function(){console.log(4)}\n")])])]),e("h2",{attrs:{id:"_11-0-冒泡排序"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_11-0-冒泡排序"}},[n._v("#")]),n._v(" 11.0 冒泡排序")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("  var arr = [5,3,2,4,1];\n   for(var i =0 ;i<arr.length-1;i++){\n       for(var j=0;j<arr.length-1-i;j++){\n           if(arr[j]>arr[j+1]){\n               var temp =arr[j];\n               arr[j] = arr[j+1];\n               arr[j+1] = temp;\n           }\n       }\n   }\nconsole.log(arr) //[5,4,3,2,1] \n")])])]),e("h2",{attrs:{id:"_12-0-反转数组"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_12-0-反转数组"}},[n._v("#")]),n._v(" 12.0 反转数组")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v(" var arr = [1,2,3,4,5,6,7]\n  for(var i=0;i<arr.length/2;i++){\n      var temp =arr[i];\n      arr[i] = arr[arr.length-1-i];\n      arr[arr.length-1-i] = temp;\n  }\n  console.log(arr) // [7, 6, 5, 4, 3, 2, 1]\n")])])]),e("h2",{attrs:{id:"_13-0-数组去重"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_13-0-数组去重"}},[n._v("#")]),n._v(" 13.0 数组去重")]),n._v(" "),e("p",[n._v("1.0 Set 去重")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("[...new Set(arr)] \nvar a = NaN;\na == NaN // false\nvar b = {} // b == {} // false\n")])])]),e("p",[n._v("2.0 Set 去重")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v(" function unique (arr) {\n   return Array.from(new Set(arr))\n }\n var arr = [1,1,'true','true',true,true,15,15,false,false, undefined,undefined, null,null, NaN, NaN,'NaN', 0, 0, 'a', 'a',{},{}];\n console.log(unique(arr))\n  //[1, \"true\", true, 15, false, undefined, null, NaN, \"NaN\", 0, \"a\", {}, {}]\n这种方法 无法去掉“{}”空对象\n")])])]),e("p",[n._v("3.0 双层循环，然后splice去重")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v(" function unique(arr){\n     for(var i=0;i<arr.length;i++){\n         for(var j=i+1;j<arr.length;j++){\n             if(arr[i]==arr[j]){\n                 arr.splice(j,1)\n                j--\n             }\n         }\n     }\n     return arr;\n }\nvar arr = [1,1,'true','true',true,true,15,15,false,false, undefined,undefined, null,null, NaN, NaN,'NaN', 0, 0, 'a', 'a',{},{}];\n unique(arr);//NaN和{}没有去重，两个null直接消失了 \n")])])]),e("p",[n._v("4.0 利用indexOf去重")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("function unique(arr) {\n    if (!Array.isArray(arr)) {\n        console.log('type error!')\n        return\n    }\n    var array = [];\n    for (var i = 0; i < arr.length; i++) {\n        if (array .indexOf(arr[i]) === -1) {\n            array .push(arr[i])\n        }\n    }\n    return array;\n}\nvar arr = [1,1,'true','true',true,true,15,15,false,false, undefined,undefined, null,null, NaN, NaN,'NaN', 0, 0, 'a', 'a',{},{}];\nconsole.log(unique(arr))\n //NaN、{}没有去重 \n")])])]),e("p",[n._v("5.0 利用includes")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("function unique(arr) {\n    if (!Array.isArray(arr)) {\n        console.log('type error!')\n        return\n    }\n    var array =[];\n    for(var i = 0; i < arr.length; i++) {\n            if( !array.includes( arr[i]) ) {//includes 检测数组是否有某个值\n                    array.push(arr[i]);\n              }\n    }\n    return array\n}\nvar arr = [1,1,'true','true',true,true,15,15,false,false, undefined,undefined, null,null, NaN, NaN,'NaN', 0, 0, 'a', 'a',{},{}];\n    console.log(unique(arr))\n //{}没有去重 \n")])])]),e("p",[n._v("6.0 利用hasOwnProperty")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("function unique(arr) {\n    var obj = {};\n    return arr.filter(function(item, index, arr){\n        return obj.hasOwnProperty(typeof item + item) ? false : (obj[typeof item + item] = true)\n    })\n}\n    var arr = [1,1,'true','true',true,true,15,15,false,false, undefined,undefined, null,null, NaN, NaN,'NaN', 0, 0, 'a', 'a',{},{}];\n        console.log(unique(arr))\n//[1, \"true\", true, 15, false, undefined, null, NaN, \"NaN\", 0, \"a\", {…}]   //所有的都去重了 \n")])])]),e("p",[n._v("7.0 利用Map数据结构去重")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("function arrayNonRepeatfy(arr) {\n  let map = new Map();\n  let array = new Array();  // 数组用于返回结果\n  for (let i = 0; i < arr.length; i++) {\n    if(map .has(arr[i])) {  // 如果有该key值\n      map .set(arr[i], true); \n    } else { \n      map .set(arr[i], false);   // 如果没有该key值\n      array .push(arr[i]);\n    }\n  } \n  return array ;\n}\n var arr = [1,1,'true','true',true,true,15,15,false,false, undefined,undefined, null,null, NaN, NaN,'NaN', 0, 0, 'a', 'a',{},{}];\n    console.log(unique(arr)) \n")])])]),e("p",[n._v("创建一个空Map数据结构，遍历需要去重的数组，把数组的每一个元素作为key存到Map中。由于Map中不会出现相同的key值，所以最终得到的就是去重后的结果。")]),n._v(" "),e("h2",{attrs:{id:"_15-0-闭包"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_15-0-闭包"}},[n._v("#")]),n._v(" 15.0 闭包")]),n._v(" "),e("blockquote",[e("p",[n._v("MDN概念：闭包是函数和声明该函数的词法环境的组合"),e("br"),n._v("\n是指有权访问另一个函数作用域中的变量的函数")])]),n._v(" "),e("p",[e("strong",[n._v("形成条件")]),e("br")]),n._v(" "),e("ol",[e("li",[n._v("函数嵌套")]),n._v(" "),e("li",[n._v("内部函数引用外部函数的局部变量")])]),n._v(" "),e("p",[e("strong",[n._v("优点")]),e("br")]),n._v(" "),e("ul",[e("li",[n._v("延长外部函数局部变量的生命周期")])]),n._v(" "),e("p",[e("strong",[n._v("缺点")]),n._v(" "),e("br")]),n._v(" "),e("ul",[e("li",[n._v("容易造成内存泄漏")])]),n._v(" "),e("h2",{attrs:{id:"_16-0-js节点的增删该查"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_16-0-js节点的增删该查"}},[n._v("#")]),n._v(" 16.0 js节点的增删该查")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("<div id=\"box1\">1</div>\n    <div id=\"box2\">2</div>\n    <div id=\"box3\">3</div>\n</div>\n\n        var oBox = document.getElementById('box');\n        var oBox1 = document.getElementById('box1');\n        var oBox2 = document.getElementById('box2');\n        var oBox3 = document.getElementById('box3');\n        var op = document.createElement('p');\n        var opText = document.createTextNode('666');\n        op.appendChild(opText);// 推进去文本节点\n        oBox.appendChild(op); // 追加节点\n        oBox.insertBefore(op,oBox1); //\n        oBox.removeChild(oBox2);\n        oBox.replaceChild(op,oBox3); // 替换节点\n\n")])])]),e("p",[n._v("查找节点")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("getElementsByTagName() // 通过标签查找\ngetElementsByName() // 通过元素的name属性查找\ngetElementsById() // 通过元素id 查找\nquerySelector与querySelectorAll() // 分别表示满足条件的第一个元素或者所有元素。括号内的写法与CSS选择器的写法一样。\n")])])]),e("h2",{attrs:{id:"_17-0-javascript如何获取被点击的li元素是所有li元素中的第几个？"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_17-0-javascript如何获取被点击的li元素是所有li元素中的第几个？"}},[n._v("#")]),n._v(" 17.0 JavaScript如何获取被点击的li元素是所有li元素中的第几个？")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v(" var d = document.getElementsByTagName('li'); // 获取所有li元素\n     for(var i=0; i<d.length; i++){\n         d[i].index = i; // 为第i个li元素添加一个index属性，赋值为i\n         d[i].addEventListener('click',function() {\n             console.log(this.index); \n             // 为第i个li元素添加一个click事件，当元素被点击时，则会在控制台输出索引\n         })\n     }\n")])])]),e("h2",{attrs:{id:"_18-0-图片懒加载和预加载"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_18-0-图片懒加载和预加载"}},[n._v("#")]),n._v(" 18.0 图片懒加载和预加载")]),n._v(" "),e("p",[e("strong",[n._v("图片预加载")]),e("br")]),n._v(" "),e("blockquote",[e("p",[n._v("接下来极有可能用到的图片提前加载 下来")])]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("// 存放图片路径的数组\n    var imgSrcArr = [\n        'imgsrc1.png',\n        'imgsrc2.png',\n        'imgsrc3.png',\n        'imgsrc4.png'\n    ];\n\n    var imgWrap = [];\n\n    function preloadImg(arr) {\n        for(var i =0; i< arr.length ;i++) {\n        \t// 创建n个 image 对象 \n            imgWrap[i] = new Image(); \n            imgWrap[i].src = arr[i];\n        }\n    }\n    # 调用方法\n    preloadImg(imgSrcArr);\n\n    # 或者延迟的文档加载完毕在加载图片(调用此方法)\n    $(function () {\n        preloadImg(imgSrcArr);\n    })\n")])])]),e("p",[e("strong",[n._v("图片懒加载")]),e("br")]),n._v(" "),e("blockquote",[e("p",[n._v("当打开一个有很多图片的页面时，先只加载页面上看到的图片，等滚动到页面下面时，再加载所需的图片。这就是图片懒加载。\n减少或延迟请求数，缓解浏览器的压力，增强用户体验。")])]),n._v(" "),e("p",[e("a",{attrs:{href:"https://www.jianshu.com/p/6d3e38728c10",target:"_blank",rel:"noopener noreferrer"}},[n._v("参考"),e("OutboundLink")],1)]),n._v(" "),e("h2",{attrs:{id:"_19-0-作用域问题"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_19-0-作用域问题"}},[n._v("#")]),n._v(" 19.0 作用域问题")]),n._v(" "),e("blockquote",[e("p",[n._v("JavaScript语言的作用域仅存在于函数范围中。这是必须要牢记的一点，还有一点重要的就是作用域的提升规则。")])]),n._v(" "),e("p",[e("strong",[n._v("变量被提升了")])]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("var x = 10;\nfunction x(){};\nconsole.log(x); // 10\n实际上被解释为:\nvar x;\nfunction x(){};\nx = 10;\nconsole.log(x); // 10 \n")])])]),e("p",[e("strong",[n._v("函数被提升")])]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v('function test() {\n    foo(); // TypeError "foo is not a function"\n    bar(); // "this will run!"\n    var foo = function () { // function expression assigned to local variable \'foo\'\n        alert("this won\'t run!");\n    }\n    function bar() { // function declaration, given the name \'bar\'\n        alert("this will run!");\n    }\n}\ntest();\n实际上等价于:\nfunction test() {\n    var foo;\n    var bar;\n    bar = function () { // function declaration, given the name \'bar\'\n        alert("this will run!");\n    }\n\n    foo(); // TypeError "foo is not a function"\n    bar(); // "this will run!"\n\n    foo = function () { // function expression assigned to local variable \'foo\'\n        alert("this won\'t run!");\n    }\n}\ntest();\n主要注意的地方：带有命名的函数变量式声明，是不会提升到作用域范围内的，比如:\nvar baz = function spam() {};\nbaz(); // vaild\nspam(); // ReferenceError "spam is not defined" \n\n')])])]),e("h2",{attrs:{id:"_20-0-a和a"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_20-0-a和a"}},[n._v("#")]),n._v(" 20.0 ++a和a++")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("var a = 1\nvar b = ++a // 2 先加再赋值\nvar a = 1\nvar c = a++ //1 先赋值再加\n\nvar a = 3;\nvar goos = function(){\nreturn a++;\n　　} \nconsole.log(goos()); // 3\n\nvar a = 3;\nvar goos = function(){\nreturn ++a;\n　　} \nconsole.log(goos()); //4 \n")])])]),e("h2",{attrs:{id:"_22-0-null-和-undefined-区别"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_22-0-null-和-undefined-区别"}},[n._v("#")]),n._v(" 22.0 null 和 undefined 区别")]),n._v(" "),e("ul",[e("li",[e("p",[n._v("undefined 一般都来自于某个表达式最原始的状态值，不是人为操作的结果。当然，你也可以手动给一个变量赋值 undefined，但这样做没有意义，因为一个变量不赋值就是 undefined")])]),n._v(" "),e("li",[e("p",[n._v("null 的字面意思是 空值 ，这个值的语义是，希望表示 一个对象被人为的重置为空对象，而非一个变量最原始的状态 。 在内存里的表示就是，栈中的变量没有指向堆中的内存对象，即：")])])]),n._v(" "),e("p",[e("img",{attrs:{src:"/images/js/js-null.png",alt:"avatar"}}),e("br"),n._v("\n当一个对象被赋值了null 以后，原来的对象在内存中就处于游离状态，GC 会择机回收该对象并释放内存。因此，如果需要释放某个对象，就将变量设置为null，即表示该对象已经被清空，目前无效状态。试想一下，如果此处把 null 换成 undefined 会不会感到别扭? 显然语义不通，其操作不能正确的表达其想要的行为。\n"),e("br"),n._v(" "),e("a",{attrs:{href:"https://cloud.tencent.com/developer/article/1407939",target:"_blank",rel:"noopener noreferrer"}},[n._v("参考链接"),e("OutboundLink")],1)]),n._v(" "),e("h2",{attrs:{id:"_23-0-innerhtml-和-innertext-的区别"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_23-0-innerhtml-和-innertext-的区别"}},[n._v("#")]),n._v(" 23.0 innerHTML 和 innerText 的区别")]),n._v(" "),e("ul",[e("li",[e("p",[n._v("innerHTML:也就是从对象的起始位置到终止位置的全部内容,包括Html标签。")])]),n._v(" "),e("li",[e("p",[n._v("innerText:从起始位置到终止位置的内容, 但它去除Html标签")])])]),n._v(" "),e("h2",{attrs:{id:"_24-0-js清空数组"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_24-0-js清空数组"}},[n._v("#")]),n._v(" 24.0 js清空数组")]),n._v(" "),e("ol",[e("li",[n._v("arr = []")]),n._v(" "),e("li",[n._v("arr.length = 0")]),n._v(" "),e("li",[n._v("arr.splice(0, arr.length)")]),n._v(" "),e("li",[n._v("while(arr.length){ arr.pop() }")])]),n._v(" "),e("h2",{attrs:{id:"_25-0-为什么要将js源文件的全部内容包装在一个函数中"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_25-0-为什么要将js源文件的全部内容包装在一个函数中"}},[n._v("#")]),n._v(" 25.0 为什么要将JS源文件的全部内容包装在一个函数中")]),n._v(" "),e("p",[n._v("这是一种越来越普遍的做法，被许多流行的JS库所采用。 这种技术围绕文件的整个内容创建一个闭包，最重要的是，它可以创建一个私有命名空间，从而有助于避免不同JS模块和库之间潜在的名称冲突。")]),n._v(" "),e("br"),n._v("\n该技术的另一个特性是允许为全局变量提供一个简单的别名，这在jQuery插件中经常使用。\n"),e("h2",{attrs:{id:"_26-0-将类似数组转为数组"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_26-0-将类似数组转为数组"}},[n._v("#")]),n._v(" 26.0 将类似数组转为数组")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v(' var arrayLike = {0: \'name\', 1: \'age\', 2: \'sex\', length: 3 }\n 1.0 Array.prototype.slice.call(arrayLike, 0); // ["name", "age", "sex"] \n // slice可以做到类数组转数组\n \n 2.0 Array.prototype.map.call(arrayLike, function(item){\n     return item.toUpperCase();\n }); \n // ["NAME", "AGE", "SEX"]\n\n// 3. ES6 Array.from\nArray.from(arrayLike); // ["name", "age", "sex"] \n// 4. apply\nArray.prototype.concat.apply([], arrayLike)\n')])])]),e("p",[n._v("特别的：")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v(" function func(...arguments) {\n     console.log(arguments); // [1, 2, 3]\n }\n \n func(1, 2, 3);\n")])])]),e("h2",{attrs:{id:"_27-0-js-格式化数字，数字每隔三位加个逗号"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_27-0-js-格式化数字，数字每隔三位加个逗号"}},[n._v("#")]),n._v(" 27.0 js 格式化数字，数字每隔三位加个逗号")]),n._v(" "),e("p",[n._v("下面这个方法这只适用于 正整数")]),n._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[n._v("function formattedNumber(num) {\n    var num = (num || 0).toString();\n    var result = '';\n    while (num.length > 3) {\n        result = ',' + num.slice(-3) + result;\n        num = num.slice(0, num.length - 3);\n    }\n    if (num) { result = num + result; }\n    return result;\n}\n")])])]),e("h2",{attrs:{id:"_28-0-栈和堆"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_28-0-栈和堆"}},[n._v("#")]),n._v(" 28.0 栈和堆")]),n._v(" "),e("p",[n._v("栈(stack)：栈会自动分配内存空间，会自动释放，存放基本类型，简单的数据段，占据固定大小的空间。（基本类型：String，Number，Boolean，Null，Undefined）"),e("br"),n._v("\n堆(heap)：动态分配的内存，大小不定也不会自动释放，存放引用类型，指那些可能由多个值构成的对象，保存在堆内存中，包含引用类型的变量，实际上保存的不是变量本身，而是指向该对象的指针。（引用类型：Function，Array，Object）")]),n._v(" "),e("p",[e("strong",[n._v("栈和堆的溢出")])]),n._v(" "),e("p",[n._v("栈：可以递归调用方法，这样随着栈深度的增加，JVM维持着一条长长的方法调用轨迹，知道内存不够分配，产生栈溢出。\n"),e("br"),n._v("\n堆：循环创建对象，通俗点就是不断的new 一个对象。")]),n._v(" "),e("p",[e("strong",[n._v("区别")])]),n._v(" "),e("p",[n._v("栈：所有在方法中定义的变量都是放在栈内存中，随着方法的执行结束，这个方法的内存栈也自然销毁。\n"),e("br"),n._v("\n优点：存取速度比堆快，仅次于直接位于CPU中的寄存器，数据可以共享；\n"),e("br"),n._v("\n缺点：存在栈中的数据大小与生存期必须是确定的，缺乏灵活性。\n"),e("br"),n._v("\n堆：堆内存中的对象不会随方法的结束而销毁，即使方法结束后，这个对象还可能被另一个引用变量所引用(参数传递)。创建对象是为了反复利用，这个对象将被保存到运行时数据区")]),n._v(" "),e("h2",{attrs:{id:"_29-0-垃圾回收"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_29-0-垃圾回收"}},[n._v("#")]),n._v(" 29.0 垃圾回收")]),n._v(" "),e("blockquote",[e("p",[n._v("JavaScript 是使用垃圾回收的编程语言，开发者不需要操心内存分配和回收。JavaScript 的垃圾回收\n程序可以总结如下")])]),n._v(" "),e("ol",[e("li",[n._v("离开作用域的值会被自动标记为可回收，然后在垃圾回收期间被删除。")]),n._v(" "),e("li",[n._v("主流的垃圾回收算法是标记清理，即先给当前不使用的值加上标记，再回来回收它们的内存。\n图灵社区会")]),n._v(" "),e("li",[n._v("引用计数是另一种垃圾回收策略，需要记录值被引用了多少次。JavaScript 引擎不再使用这种算\n法，但某些旧版本的 IE 仍然会受这种算法的影响，原因是 JavaScript 会访问非原生 JavaScript 对\n象（如 DOM 元素）。")]),n._v(" "),e("li",[n._v("引用计数在代码中存在循环引用时会出现问题。")]),n._v(" "),e("li",[n._v("解除变量的引用不仅可以消除循环引用，而且对垃圾回收也有帮助。为促进内存回收，全局对\n象、全局对象的属性和循环引用都应该在不需要时解除引用。")])])])}),[],!1,null,null,null);a.default=t.exports}}]);