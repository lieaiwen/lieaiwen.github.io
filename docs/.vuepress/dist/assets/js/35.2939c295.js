(window.webpackJsonp=window.webpackJsonp||[]).push([[35],{225:function(e,n,t){"use strict";t.r(n);var a=t(6),r=Object(a.a)({},(function(){var e=this,n=e.$createElement,t=e._self._c||n;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("h2",{attrs:{id:"es6-相关知识点"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#es6-相关知识点"}},[e._v("#")]),e._v(" es6 相关知识点")]),e._v(" "),t("h2",{attrs:{id:"_1-0-let-和const"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1-0-let-和const"}},[e._v("#")]),e._v(" 1.0 let 和const")]),e._v(" "),t("h2",{attrs:{id:"_2-0-解构赋值"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-0-解构赋值"}},[e._v("#")]),e._v(" 2.0 解构赋值")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("let [a, b, c] = [1, 2, 3];\n\n不完全解构\nlet [a = 1, b] = []; // a = 1, b = undefined\n\n剩余运算符\nlet [a, ...b] = [1, 2, 3]; \n//a = 1\n//b = [2, 3]\n\n对象模型的解构\n let { foo, bar } = { foo: 'aaa', bar: 'bbb' };\n\n解构默认值\nlet {a = 10, b = 5} = {a: 3};\n")])])]),t("h2",{attrs:{id:"_3-0-promise"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3-0-promise"}},[e._v("#")]),e._v(" 3.0 promise")]),e._v(" "),t("p",[e._v("是异步编程的一种解决方案。"),t("br")]),e._v(" "),t("p",[e._v("从语法上说，Promise 是一个对象，从它可以获取异步操作的消息。"),t("br")]),e._v(" "),t("p",[t("strong",[e._v("状态的特点")]),t("br"),e._v("\nPromise 异步操作有三种状态：pending（进行中）、fulfilled（已成功）和 rejected（已失败）。除了异步操作的结果，任何其他操作都无法改变这个状态。\n"),t("br"),e._v("\nPromise 对象只有：从 pending 变为 fulfilled 和从 pending 变为 rejected 的状态改变。只要处于 fulfilled 和 rejected ，状态就不会再变了即 resolved（已定型）。"),t("br")]),e._v(" "),t("p",[t("strong",[e._v("状态的缺点")]),t("br"),e._v("\n无法取消 Promise ，一旦新建它就会立即执行，无法中途取消。\n"),t("br"),e._v("\n如果不设置回调函数，Promise 内部抛出的错误，不会反应到外部。\n"),t("br"),e._v("\n当处于 pending 状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）。\n"),t("br")]),e._v(" "),t("h2",{attrs:{id:"generator"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#generator"}},[e._v("#")]),e._v(" Generator")]),e._v(" "),t("p",[e._v("ES6 新引入了 Generator 函数，可以通过 yield 关键字，把函数的执行流挂起，为改变执行流程提供了可能，从而为异步编程提供解决方案。 基本用法")]),e._v(" "),t("h2",{attrs:{id:"_4-0-async"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_4-0-async"}},[e._v("#")]),e._v(" 4.0 async")]),e._v(" "),t("p",[e._v("async 函数返回一个 Promise 对象，可以使用 then 方法添加回调函数。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v(' function testAwait(){\n    return new Promise((resolve) => {\n        setTimeout(function(){\n           console.log("testAwait");\n           resolve();\n        }, 1000);\n    });\n }\n  \n async function helloAsync(){\n    await testAwait();\n    console.log("helloAsync");\n  }\n helloAsync();\n // testAwait\n // helloAsync\n')])])]),t("p",[e._v("await 关键字仅在 async function 中有效。如果在 async function 函数体外使用 await ，你只会得到一个语法错误。")]),e._v(" "),t("h2",{attrs:{id:"_5-0-函数"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_5-0-函数"}},[e._v("#")]),e._v(" 5.0 函数")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v(' 1.0 函数参数的扩展  默认参数\nfunction fn(name,age=17){\n console.log(name+","+age);\n}\nfn("Amy",18);  // Amy,18\nfn("Amy","");  // Amy,\nfn("Amy");     // Amy,17\n\n2.0 不定参数\nfunction f(...values){\n    console.log(values.length);\n}\nf(1,2);      //2\nf(1,2,3,4);  //4\n\n3.0 箭头函数\n')])])]),t("h2",{attrs:{id:"_4-0-symbol-数据类型"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_4-0-symbol-数据类型"}},[e._v("#")]),e._v(" 4.0 Symbol 数据类型")]),e._v(" "),t("blockquote",[t("p",[e._v("ES6 引入了一种新的原始数据类型 Symbol ，表示独一无二的值，最大的用法是用来定义对象的唯一属性名。")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('let sy = Symbol("KK");\nconsole.log(sy);   // Symbol(KK)\ntypeof(sy);        // "symbol"\n \n// 相同参数 Symbol() 返回的值不相等\nlet sy1 = Symbol("kk"); \nsy === sy1;       // false\n')])])]),t("p",[t("strong",[e._v("用法")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('let sy = Symbol("key1");\n \n// 写法1\nlet syObject = {};\nsyObject[sy] = "kk";\nconsole.log(syObject);    // {Symbol(key1): "kk"}\n \n// 写法2\nlet syObject = {\n  [sy]: "kk"\n};\nconsole.log(syObject);    // {Symbol(key1): "kk"}\n \n// 写法3\nlet syObject = {};\nObject.defineProperty(syObject, sy, {value: "kk"});\nconsole.log(syObject);   // {Symbol(key1): "kk"}\n')])])]),t("p",[t("strong",[e._v("注意点")])]),e._v(" "),t("p",[e._v("Symbol 值作为属性名时，该属性是公有属性不是私有属性，可以在类的外部访问。但是不会出现在 for...in 、 for...of 的循环中，也不会被 Object.keys() 、 Object.getOwnPropertyNames() 返回。如果要读取到一个对象的 Symbol 属性，可以通过 Object.getOwnPropertySymbols() 和 Reflect.ownKeys() 取到。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v(' let syObject = {};\n syObject[sy] = "kk";\n console.log(syObject);\n  \n for (let i in syObject) {\n   console.log(i);\n }    // 无输出\n  \n Object.keys(syObject);                     // []\n Object.getOwnPropertySymbols(syObject);    // [Symbol(key1)]\n Reflect.ownKeys(syObject);                 // [Symbol(key1)]\n')])])]),t("h2",{attrs:{id:"_5-0-set-对象-和map对象"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_5-0-set-对象-和map对象"}},[e._v("#")]),e._v(" 5.0 Set 对象 和map对象")]),e._v(" "),t("blockquote",[t("p",[e._v("Set 对象允许你存储任何类型的唯一值，无论是原始值或者是对象引用。"),t("br"),e._v("\nSet 中的特殊值"),t("br")])]),e._v(" "),t("p",[e._v("Set 对象存储的值总是唯一的，所以需要判断两个值是否恒等。有几个特殊值需要特殊对待："),t("br")]),e._v(" "),t("ul",[t("li",[e._v("+0 与 -0 在存储判断唯一性的时候是恒等的，所以不重复；\n*undefined 与 undefined 是恒等的，所以不重复；")]),e._v(" "),t("li",[e._v("NaN 与 NaN 是不恒等的，但是在 Set 中只能存一个，不重复。")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v(' let mySet = new Set();\n  \n mySet.add(1); // Set(1) {1}\n mySet.add(5); // Set(2) {1, 5}\n mySet.add(5); // Set(2) {1, 5} 这里体现了值的唯一性\n mySet.add("some text"); \n // Set(3) {1, 5, "some text"} 这里体现了类型的多样性\n var o = {a: 1, b: 2}; \n mySet.add(o);\n mySet.add({a: 1, b: 2}); \n // Set(5) {1, 5, "some text", {…}, {…}} \n // 这里体现了对象之间引用不同不恒等，即使值相同，Set 也能存储\n')])])]),t("p",[t("strong",[e._v("类型转换")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v(' // Array 转 Set\n var mySet = new Set(["value1", "value2", "value3"]);\n // 用...操作符，将 Set 转 Array\n var myArray = [...mySet];\n String\n // String 转 Set\n var mySet = new Set(\'hello\');  // Set(4) {"h", "e", "l", "o"}\n // 注：Set 中 toString 方法是不能将 Set 转换成 String\n')])])]),t("p",[t("strong",[e._v("Set 对象作用")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v(" 1.0 数组去重\nvar mySet = new Set([1, 2, 3, 4, 4]);\n[...mySet]; // [1, 2, 3, 4]\n\n2.0 并集\nvar a = new Set([1, 2, 3]);\nvar b = new Set([4, 3, 2]);\nvar union = new Set([...a, ...b]); // {1, 2, 3, 4}\n\n3.0 交集\n\nvar a = new Set([1, 2, 3]);\nvar b = new Set([4, 3, 2]);\nvar intersect = new Set([...a].filter(x => b.has(x))); // {2, 3}\n\n4.0 差集\nvar a = new Set([1, 2, 3]);\nvar b = new Set([4, 3, 2]);\nvar difference = new Set([...a].filter(x => !b.has(x))); // {1}\n")])])]),t("p",[e._v("Set常用属性及增删改查方法:")]),e._v(" "),t("ul",[t("li",[e._v("size属性: 返回集合的元素个数。（类似数组的长度length）")]),e._v(" "),t("li",[e._v("add(value)方法: 向集合中添加一个元素value。注意：如果向集合中添加一个已经存在的元素，不报错但是集合不会改变。")]),e._v(" "),t("li",[e._v("delete(value)方法: 从集合中删除元素value。")]),e._v(" "),t("li",[e._v("has(value)方法: 判断value是否在集合中，返回true或false.")]),e._v(" "),t("li",[e._v("clear()方法: 清空集合。")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v(" let mySet = new Set([1, 2, 3, 2, 1]);\n console.log(mySet.size);   //3\n console.log(...mySet);      //1,2,3\n mySet.add(4);\n console.log(mySet.size);   //4\n mySet.delete(3);\n console.log(mySet.size);  //3\n console.log(mySet.has(2));  //true\n mySet.clear();\n console.log(mySet.size);  //0\n")])])]),t("p",[t("strong",[e._v("Map(字典)：")]),e._v("\n集合与字典的区别:")]),e._v(" "),t("ul",[t("li",[e._v("同: 集合和字典都是存储不重复的值.")]),e._v(" "),t("li",[e._v("异: 集合中是以[value,value]存储的，字典中是以[key,value]存储的。")])]),e._v(" "),t("p",[e._v("Map 对象保存键值对。任何值(对象或者原始值) 都可以作为一个键或一个值。\n"),t("strong",[e._v("Maps 和 Objects 的区别")])]),e._v(" "),t("ul",[t("li",[e._v("一个 Object 的键只能是字符串或者 Symbols，但一个 Map 的键可以是任意值。")]),e._v(" "),t("li",[e._v("Map 中的键值是有序的（FIFO 原则），而添加到对象中的键则不是。")]),e._v(" "),t("li",[e._v("Map 的键值对个数可以从 size 属性获取，而 Object 的键值对个数只能手动计算。")]),e._v(" "),t("li",[e._v("Object 都有自己的原型，原型链上的键名有可能和你自己在对象上的设置的键名产生冲突。")])]),e._v(" "),t("p",[t("strong",[e._v("Map 中的 key")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('1. key 是字符串\nvar myMap = new Map();\nvar keyString = "a string"; \n \nmyMap.set(keyString, "和键\'a string\'关联的值");\n \nmyMap.get(keyString);    // "和键\'a string\'关联的值"\nmyMap.get("a string");   // "和键\'a string\'关联的值"\n                         // 因为 keyString === \'a string\'\n\n2.0 key 是对象\nvar myMap = new Map();\nvar keyObj = {}, \n \nmyMap.set(keyObj, "和键 keyObj 关联的值");\n\ufeff\nmyMap.get(keyObj); // "和键 keyObj 关联的值"\nmyMap.get({}); // undefined, 因为 keyObj !== {}\n\n3.0 key 是函数\nvar myMap = new Map();\nvar keyFunc = function () {}, // 函数\n \nmyMap.set(keyFunc, "和键 keyFunc 关联的值");\n \nmyMap.get(keyFunc); // "和键 keyFunc 关联的值"\nmyMap.get(function() {}) // undefined, 因为 keyFunc !== function () {}\n\n4.0 key 是 NaN\nvar myMap = new Map();\nmyMap.set(NaN, "not a number");\n \nmyMap.get(NaN); // "not a number"\n \nvar otherNaN = Number("foo");\nmyMap.get(otherNaN); // "not a number"\n虽然 NaN 和任何值甚至和自己都不相等(NaN !== NaN 返回true)，NaN作为Map的键来说是没有区别的。\n')])])]),t("p",[t("strong",[e._v("Map 的迭代")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v(' 1.0 for...of\nvar myMap = new Map();\nmyMap.set(0, "zero");\nmyMap.set(1, "one");\n \n// 将会显示两个 log。 一个是 "0 = zero" 另一个是 "1 = one"\nfor (var [key, value] of myMap) {\n  console.log(key + " = " + value);\n}\nfor (var [key, value] of myMap.entries()) {\n  console.log(key + " = " + value);\n}\n/* 这个 entries 方法返回一个新的 Iterator 对象，它按插入顺序包含了 Map 对象中每个元素的 [key, value] 数组。 */\n \n// 将会显示两个log。 一个是 "0" 另一个是 "1"\nfor (var key of myMap.keys()) {\n  console.log(key);\n}\n/* 这个 keys 方法返回一个新的 Iterator 对象， 它按插入顺序包含了 Map 对象中每个元素的键。 */\n \n// 将会显示两个log。 一个是 "zero" 另一个是 "one"\nfor (var value of myMap.values()) {\n  console.log(value);\n}\n/* 这个 values 方法返回一个新的 Iterator 对象，它按插入顺序包含了 Map 对象中每个元素的值。 */\n\n2.0 forEach()\nvar myMap = new Map();\nmyMap.set(0, "zero");\nmyMap.set(1, "one");\n \n// 将会显示两个 logs。 一个是 "0 = zero" 另一个是 "1 = one"\nmyMap.forEach(function(value, key) {\n  console.log(key + " = " + value);\n}, myMap)\n')])])]),t("p",[t("strong",[e._v("Map 对象的操作")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('1.0 Map 与 Array的转换\nvar kvArray = [["key1", "value1"], ["key2", "value2"]];\n \n// Map 构造函数可以将一个 二维 键值对数组转换成一个 Map 对象\nvar myMap = new Map(kvArray);\n \n// 使用 Array.from 函数可以将一个 Map 对象转换成一个二维键值对数组\nvar outArray = Array.from(myMap);\n\n2.0 Map 的克隆\nvar myMap1 = new Map([["key1", "value1"], ["key2", "value2"]]);\nvar myMap2 = new Map(myMap1);\n \nconsole.log(original === clone); \n// 打印 false。 Map 对象构造函数生成实例，迭代出新的对象。\n\n3.0 Map 的合并\nvar first = new Map([[1, \'one\'], [2, \'two\'], [3, \'three\'],]);\nvar second = new Map([[1, \'uno\'], [2, \'dos\']]);\n \n// 合并两个 Map 对象时，如果有重复的键值，则后面的会覆盖前面的，对应值即 uno，dos， three\nvar merged = new Map([...first, ...second]);\n\n')])])]),t("p",[e._v("Map常用属性及增删改查方法:")]),e._v(" "),t("ul",[t("li",[e._v("size: 属性，取出字典的长度")]),e._v(" "),t("li",[e._v("set(key, value)：方法，向字典中添加新元素")]),e._v(" "),t("li",[e._v("get(key)：方法，通过键查找特定的数值并返回")]),e._v(" "),t("li",[e._v("has(key)：方法，判断字典中是否存在键key")]),e._v(" "),t("li",[e._v("delete(key)：方法，通过键 key 从字典中移除对应的数据")]),e._v(" "),t("li",[e._v("clear()：方法，将这个字典中的所有元素删除")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v(' let myMap = new Map();\n myMap.set("name","Jack");    \n myMap.set("age","18");     //添加元素\n console.log(myMap.size);  //2\n console.log(myMap.get("name"));//Jack\n console.log(myMap.has("name")); //true\n myMap.delete("age"); //删除\n console.log(myMap.size); //1\n console.log(myMap.has("age")); //false\n myMap.clear();    //清空元素\n console.log(myMap.size); //0\n')])])]),t("p",[e._v("Map常用遍历方法:")]),e._v(" "),t("ul",[t("li",[e._v("Keys()：将字典中包含的所有键名以迭代器形式返回")]),e._v(" "),t("li",[e._v("values()：将字典中包含的所有数值以迭代器形式返回")]),e._v(" "),t("li",[e._v("entries()：返回所有成员的迭代器")]),e._v(" "),t("li",[e._v("forEach()：遍历字典的所有成员")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v(' let myMap = new Map();\n myMap.set("name","Jack");\n myMap.set("age","18");\n myMap.set("sex","man");\n \n myMap.forEach(\n   (value,key,map)=>{\n     console.log(value);    //Jack,18,man\n     console.log(key);  //name,age,sex\n     console.log(map); //自身，自身，自身\n   }\n )\n')])])]),t("h2",{attrs:{id:"_6-0-es6-reflect-与-proxy"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_6-0-es6-reflect-与-proxy"}},[e._v("#")]),e._v(" 6.0 ES6 Reflect 与 Proxy")]),e._v(" "),t("p",[e._v("Proxy 与 Reflect 是 ES6 为了操作对象引入的 API 。\n"),t("br"),e._v("\nProxy 可以对目标对象的读取、函数调用等操作进行拦截，然后进行操作处理。它不直接操作对象，而是像代理模式，通过对象的代理对象进行操作，在进行这些操作时，可以添加一些需要的额外操作。\n"),t("br"),e._v("\nReflect 可以用于获取目标对象的行为，它与 Object 类似，但是更易读，为操作对象提供了一种更优雅的方式。它的方法与 Proxy 是对应的。"),t("br")]),e._v(" "),t("p",[t("strong",[e._v("基本用法")]),e._v("\n一个 Proxy 对象由两个部分组成： target 、 handler 。在通过 Proxy 构造函数生成实例对象时，需要提供这两个参数。 target 即目标对象， handler 是一个对象，声明了代理 target 的指定行为。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v(' let target = {\n     name: \'Tom\',\n     age: 24\n }\n let handler = {\n     get: function(target, key) {\n         console.log(\'getting \'+key);\n         return target[key]; // 不是target.key\n     },\n     set: function(target, key, value) {\n         console.log(\'setting \'+key);\n         target[key] = value;\n     }\n }\n let proxy = new Proxy(target, handler)\n proxy.name     // 实际执行 handler.get\n proxy.age = 25 // 实际执行 handler.set\n // getting name\n // setting age\n // 25\n  \n // target 可以为空对象\n let targetEpt = {}\n let proxyEpt = new Proxy(targetEpt, handler)\n // 调用 get 方法，此时目标对象为空，没有 name 属性\n proxyEpt.name // getting name\n // 调用 set 方法，向目标对象中添加了 name 属性\n proxyEpt.name = \'Tom\'\n // setting name\n // "Tom"\n // 再次调用 get ，此时已经存在 name 属性\n proxyEpt.name\n // getting name\n // "Tom"\n  \n // 通过构造函数新建实例时其实是对目标对象进行了浅拷贝，因此目标对象与代理对象会互相\n // 影响\n targetEpt)\n // {name: "Tom"}\n  \n // handler 对象也可以为空，相当于不设置拦截操作，直接访问目标对象\n let targetEmpty = {}\n let proxyEmpty = new Proxy(targetEmpty,{})\n proxyEmpty.name = "Tom"\n targetEmpty) // {name: "Tom"}\n')])])]),t("p",[t("strong",[e._v("实例方法")])]),e._v(" "),t("blockquote",[t("p",[e._v("get(target, propKey, receiver)")])]),e._v(" "),t("p",[e._v("用于 target 对象上 propKey 的读取操作。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v(' let exam ={\n     name: "Tom",\n     age: 24\n }\n let proxy = new Proxy(exam, {\n   get(target, propKey, receiver) {\n     console.log(\'Getting \' + propKey);\n     return target[propKey];\n   }\n })\n proxy.name \n // Getting name\n // "Tom"\n')])])]),t("p",[e._v("get() 方法可以继承。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v(" let proxy = new Proxy({}, {\n   get(target, propKey, receiver) {\n       // 实现私有属性读取保护\n       if(propKey[0] === '_'){\n           throw new Erro(`Invalid attempt to get private     \"${propKey}\"`);\n       }\n       console.log('Getting ' + propKey);\n       return target[propKey];\n   }\n });\n  \n let obj = Object.create(proxy);\n obj.name\n // Getting name\n")])])]),t("blockquote",[t("p",[e._v("set(target, propKey, value, receiver)")])]),e._v(" "),t("p",[e._v("用于拦截 target 对象上的 propKey 的赋值操作。如果目标对象自身的某个属性，不可写且不可配置，那么set方法将不起作用。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v(" let validator = {\n     set: function(obj, prop, value) {\n         if (prop === 'age') {\n             if (!Number.isInteger(value)) {\n                 throw new TypeError('The age is not an integer');\n             }\n             if (value > 200) {\n                 throw new RangeError('The age seems invalid');\n             }\n         }\n         // 对于满足条件的 age 属性以及其他属性，直接保存\n         obj[prop] = value;\n     }\n };\n let proxy= new Proxy({}, validator)\n proxy.age = 100;\n proxy.age           // 100\n proxy.age = 'oppps' // 报错\n proxy.age = 300     // 报错\n")])])]),t("p",[e._v("第四个参数 receiver 表示原始操作行为所在对象，一般是 Proxy 实例本身。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v(" const handler = {\n     set: function(obj, prop, value, receiver) {\n         obj[prop] = receiver;\n     }\n };\n const proxy = new Proxy({}, handler);\n proxy.name= 'Tom';\n proxy.name=== proxy // true\n  \n const exam = {}\n Object.setPrototypeOf(exam, proxy)\n exam.name = \"Tom\"\n exam.name === exam // true\n")])])]),t("p",[e._v("注意，严格模式下，set代理如果没有返回true，就会报错。")]),e._v(" "),t("p",[t("strong",[e._v("apply(target, ctx, args)")]),t("br"),e._v("\n用于拦截函数的调用、call 和 reply 操作。target 表示目标对象，ctx 表示目标对象上下文，args 表示目标对象的参数数组。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v(" function sub(a, b){\n     return a - b;\n }\n let handler = {\n     apply: function(target, ctx, args){\n         console.log('handle apply');\n         return Reflect.apply(...arguments);\n     }\n }\n let proxy = new Proxy(sub, handler)\n proxy(2, 1) \n // handle apply\n // 1\n")])])]),t("blockquote",[t("p",[e._v("has(target, propKey)")])]),e._v(" "),t("p",[e._v("用于拦截 HasProperty 操作，即在判断 target 对象是否存在 propKey 属性时，会被这个方法拦截。此方法不判断一个属性是对象自身的属性，还是继承的属性。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v(' let  handler = {\n     has: function(target, propKey){\n         console.log("handle has");\n         return propKey in target;\n     }\n }\n let exam = {name: "Tom"}\n let proxy = new Proxy(exam, handler)\n \'name\' in proxy\n // handle has\n // true\n注意：此方法不拦截 for ... in 循环。\n')])])]),t("blockquote",[t("p",[e._v("construct(target, args)")])]),e._v(" "),t("p",[e._v("用于拦截 new 命令。返回值必须为对象。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v(" let handler = {\n     construct: function (target, args, newTarget) {\n         console.log('handle construct')\n         return Reflect.construct(target, args, newTarget)  \n     }\n }\n class Exam { \n     constructor (name) {  \n         this.name = name \n     }\n }\n let ExamProxy = new Proxy(Exam, handler)\n let proxyObj = new ExamProxy('Tom')\n console.log(proxyObj)\n // handle construct\n // exam {name: \"Tom\"}\n")])])]),t("blockquote",[t("p",[e._v("deleteProperty(target, propKey)")])]),e._v(" "),t("p",[e._v("用于拦截 delete 操作，如果这个方法抛出错误或者返回 false ，propKey 属性就无法被 delete 命令删除。")]),e._v(" "),t("blockquote",[t("p",[e._v("defineProperty(target, propKey, propDesc)")])]),e._v(" "),t("p",[e._v("用于拦截 Object.definePro若目标对象不可扩展，增加目标对象上不存在的属性会报错；若属性不可写或不可配置，则不能改变这些属性。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v(' let handler = {\n     defineProperty: function(target, propKey, propDesc){\n         console.log("handle defineProperty");\n         return true;\n     }\n }plet target = {}\n let proxy = new Proxy(target, handler)\n proxy.name = "Tom"\n // handle defineProperty\n target\n // {name: "Tom"}\n  \n // defineProperty 返回值为false，添加属性操作无效\n let handler1 = {\n     defineProperty: function(target, propKey, propDesc){\n         console.log("handle defineProperty");\n         return false;\n     }\n }\n let target1 = {}\n let proxy1 = new Proxy(target1, handler1)\n proxy1.name = "Jerry"\n target1\n // {}\n')])])]),t("p",[e._v("erty 操作")]),e._v(" "),t("blockquote",[t("p",[e._v("getOwnPropertyDescriptor(target, propKey)")])]),e._v(" "),t("p",[e._v("用于拦截 Object.getOwnPropertyD() 返回值为属性描述对象或者 undefined 。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v(' let handler = {\n     getOwnPropertyDescriptor: function(target, propKey){\n         return Object.getOwnPropertyDescriptor(target, propKey);\n     }\n }\n let target = {name: "Tom"}\n let proxy = new Proxy(target, handler)\n Object.getOwnPropertyDescriptor(proxy, \'name\')\n // {value: "Tom", writable: true, enumerable: true, configurable: \n // true}\n')])])]),t("p",[e._v("ptor 属性")]),e._v(" "),t("blockquote",[t("p",[e._v("getPrototypeOf(target)")])]),e._v(" "),t("p",[e._v("主要用于拦截获取对象原型的操作。包括以下操作：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("- Object.prototype._proto_\n- Object.prototype.isPrototypeOf()\n- Object.getPrototypeOf()\n- Reflect.getPrototypeOf()\n- instanceof\n\nlet exam = {}\nlet proxy = new Proxy({},{\n    getPrototypeOf: function(target){\n        return exam;\n    }\n})\nObject.getPrototypeOf(proxy) // {} \n")])])]),t("p",[e._v("注意，返回值必须是对象或者 null ，否则报错。另外，如果目标对象不可扩展（non-extensible），getPrototypeOf 方法必须返回目标对象的原型对象。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("let proxy = new Proxy({},{\n    getPrototypeOf: function(target){\n        return true;\n    }\n})\nObject.getPrototypeOf(proxy)\n// TypeError: 'getPrototypeOf' on proxy: trap returned neither object // nor null \n")])])]),t("blockquote",[t("p",[e._v("isExtensible(target)")])]),e._v(" "),t("p",[e._v("用于拦截 Object.isExtensible 操作。\n"),t("br"),e._v("\n该方法只能返回布尔值，否则返回值会被自动转为布尔值")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("let proxy = new Proxy({},{\n    isExtensible:function(target){\n        return true;\n    }\n})\nObject.isExtensible(proxy) // true\n\n注意：它的返回值必须与目标对象的isExtensible属性保持一致，否则会抛出错误。\n\nlet proxy = new Proxy({},{\n    isExtensible:function(target){\n        return false;\n    }\n})\nObject.isExtensible(proxy)\n// TypeError: 'isExtensible' on proxy: trap result does not reflect \n// extensibility of proxy target (which is 'true') \n")])])]),t("blockquote",[t("p",[e._v("ownKeys(target)")])]),e._v(" "),t("p",[e._v("用于拦截对象自身属性的读取操作。主要包括以下操作：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v(" - Object.getOwnPropertyNames()\n - Object.getOwnPropertySymbols()\n - Object.keys()\n - or...in\n\n方法返回的数组成员，只能是字符串或 Symbol 值，否则会报错。\n\n若目标对象中含有不可配置的属性，则必须将这些属性在结果中返回，否则就会报错。\n\n若目标对象不可扩展，则必须全部返回且只能返回目标对象包含的所有属性，不能包含不存在的属性，否则也会报错。\n\nlet proxy = new Proxy( {\n  name: \"Tom\",\n  age: 24\n}, {\n    ownKeys(target) {\n        return ['name'];\n    }\n});\nObject.keys(proxy)\n// [ 'name' ]f返回结果中，三类属性会被过滤：\n//          - 目标对象上没有的属性\n//          - 属性名为 Symbol 值的属性\n//          - 不可遍历的属性\n \nlet target = {\n  name: \"Tom\",\n  [Symbol.for('age')]: 24,\n};\n// 添加不可遍历属性 'gender'\nObject.defineProperty(target, 'gender', {\n  enumerable: false,\n  configurable: true,\n  writable: true,\n  value: 'male'\n});\nlet handler = {\n    ownKeys(target) {\n        return ['name', 'parent', Symbol.for('age'), 'gender'];\n    }\n};\nlet proxy = new Proxy(target, handler);\nObject.keys(proxy)\n// ['name']\n")])])]),t("blockquote",[t("p",[e._v("preventExtensions(target)")])]),e._v(" "),t("p",[e._v("拦截 Object.preventExtensions 操作。\n"),t("br"),e._v("\n该方法必须返回一个布尔值，否则会自动转为布尔值。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v(" // 只有目标对象不可扩展时（即 Object.isExtensible(proxy) 为 false ），\n // proxy.preventExtensions 才能返回 true ，否则会报错\n var proxy = new Proxy({}, {\n   preventExtensions: function(target) {\n     return true;\n   }\n });\n // 由于 proxy.preventExtensions 返回 true，此处也会返回 true，因此会报错\n Object.preventExtensions(proxy) 被// TypeError: 'preventExtensions' on proxy: trap returned truish but // the proxy target is extensible\n  \n // 解决方案\n  var proxy = new Proxy({}, {\n   preventExtensions: function(target) {\n     // 返回前先调用 Object.preventExtensions\n     Object.preventExtensions(target);\n     return true;\n   }\n });\n Object.preventExtensions(proxy)\n // Proxy {}\n")])])]),t("blockquote",[t("p",[e._v("setPrototypeOf")])]),e._v(" "),t("p",[e._v("主要用来拦截 Object.setPrototypeOf 方法。\n"),t("br"),e._v("\n返回值必须为布尔值，否则会被自动转为布尔值。\n"),t("br"),e._v("\n若目标对象不可扩展，setPrototypeOf 方法不得改变目标对象的原型。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v(' et proto = {}\n let proxy = new Proxy(function () {}, {\n     setPrototypeOf: function(target, proto) {\n         console.log("setPrototypeOf");\n         return true;\n     }\n }\n );\n Object.setPrototypeOf(proxy, proto);\n // setPrototypeOf\n')])])]),t("blockquote",[t("p",[e._v("Proxy.revocable()")])]),e._v(" "),t("p",[e._v("用于返回一个可取消的 Proxy 实例。")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v(" let {proxy, revoke} = Proxy.revocable({}, {});\n proxy.name = \"Tom\";\n revoke();\n proxy.name \n // TypeError: Cannot perform 'get' on a proxy that has been revoked\n")])])]),t("h2",{attrs:{id:"_7-0-es6-迭代器"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_7-0-es6-迭代器"}},[e._v("#")]),e._v(" 7.0 ES6 迭代器")]),e._v(" "),t("p",[t("strong",[e._v("iterator")]),t("br"),e._v("\niterator 是 ES6 引入的一种新的遍历机制，迭代器有两个核心概念：")]),e._v(" "),t("ul",[t("li",[e._v("迭代器是一个统一的接口，它的作用是使各种数据结构可被便捷的访问，它是通过一个键为Symbol.iterator 的方法来实现。"),t("br")]),e._v(" "),t("li",[e._v("迭代器是用于遍历数据结构元素的指针（如数据库中的游标）。"),t("br")])]),e._v(" "),t("p",[t("strong",[e._v("迭代过程")]),t("br"),e._v("\n迭代的过程如下：")]),e._v(" "),t("ul",[t("li",[e._v("通过 Symbol.iterator 创建一个迭代器，指向当前数据结构的起始位置")]),e._v(" "),t("li",[e._v("随后通过 next 方法进行向下迭代指向下一个位置， next 方法会返回当前位置的对象，对象包含了 value 和 done 两个属性， value 是当前属性的值， done 用于判断是否遍历结束")]),e._v(" "),t("li",[e._v("当 done 为 true 时则遍历结束")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('const items = ["zero", "one", "two"];\nconst it = items[Symbol.iterator]();\n \nit.next();\n>{value: "zero", done: false}\nit.next();\n>{value: "one", done: false}\nit.next();\n>{value: "two", done: false}\nit.next();\n>{value: undefined, done: true} \n')])])]),t("p",[e._v("可迭代的数据结构")]),e._v(" "),t("ol",[t("li",[e._v("Array")]),e._v(" "),t("li",[e._v("String")]),e._v(" "),t("li",[e._v("Map")]),e._v(" "),t("li",[e._v("Set")]),e._v(" "),t("li",[e._v("arguments")])]),e._v(" "),t("p",[t("strong",[e._v("for...of 循环对数据结构进行迭代")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('for (let item of ["zero", "one", "two"]) {\n  console.log(item);\n}\n// zero\n// one\n// two \nfor in 不能遍历 map set结构\nfor of 不能遍历对象\nfor…of循环的是的是可迭代对象的value（值），in循环的是可迭代对象的key（属性）\n')])])])])}),[],!1,null,null,null);n.default=r.exports}}]);