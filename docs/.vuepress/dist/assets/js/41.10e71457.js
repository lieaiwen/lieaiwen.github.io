(window.webpackJsonp=window.webpackJsonp||[]).push([[41],{102:function(r,t,n){"use strict";n.r(t);var e=n(0),_=Object(e.a)({},(function(){var r=this,t=r.$createElement,n=r._self._c||t;return n("ContentSlotsDistributor",{attrs:{"slot-key":r.$parent.slotKey}},[n("h2",{attrs:{id:"什么是设计模式"}},[n("a",{staticClass:"header-anchor",attrs:{href:"#什么是设计模式"}},[r._v("#")]),r._v(" 什么是设计模式")]),r._v(" "),n("p",[r._v("一个模式就是一个可重用的方案，可应用于在软件设计中的常见问题 "),n("br"),r._v("\n模式的另一种解释就是一个我们如何解决问题的模板 - 那些可以在许多不同的情况里使用的模板。"),n("br"),r._v("\n设计模式不是高深技术，奇技淫巧，只是一种设计思想，针对不同的业务场景，最本质的目的是解耦，为了可扩展性和健壮性。")]),r._v(" "),n("p",[r._v("设计原则 "),n("br"),r._v("\n1.0 单一职责原则（SRP）"),n("br"),r._v("\n一个对象或方法只做一件事情。如果一个方法承担了过多的职责，那么在需求的变迁过程中，需要改写这个方法的可能性就越大。"),n("br"),r._v("\n应该把对象或方法划分成较小的粒度"),n("br"),r._v("\n2.0 最少知识原则（LKP）"),n("br"),r._v("\n一个软件实体应当 尽可能少地与其他实体发生相互作用 "),n("br"),r._v("\n应当尽量减少对象之间的交互。如果两个对象之间不必彼此直接通信，那么这两个对象就不要发生直接的 相互联系，可以转交给第三方进行处理"),n("br"),r._v("\n3.0 开放-封闭原则（OCP）"),n("br"),r._v("\n软件实体（类、模块、函数）等应该是可以 扩展的，但是不可修改"),n("br"),r._v("\n当需要改变一个程序的功能或者给这个程序增加新功能的时候，可以使用增加代码的方式，尽量避免改动程序的源代码，防止影响原系统的稳定"),n("br")]),r._v(" "),n("p",[r._v("主要用es6的方法 以后es5的方法也补全 "),n("br"),r._v(" "),n("a",{attrs:{href:"https://segmentfault.com/a/1190000017787537",target:"_blank",rel:"noopener noreferrer"}},[r._v("参考链接"),n("OutboundLink")],1)])])}),[],!1,null,null,null);t.default=_.exports}}]);