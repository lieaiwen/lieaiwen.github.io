(window.webpackJsonp=window.webpackJsonp||[]).push([[76],{59:function(e,n,t){"use strict";t.r(n);var l=t(0),s=Object(l.a)({},(function(){var e=this,n=e.$createElement,t=e._self._c||n;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("h2",{attrs:{id:"虚拟dom（virtual-dom）"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#虚拟dom（virtual-dom）"}},[e._v("#")]),e._v(" 虚拟Dom（Virtual Dom）")]),e._v(" "),t("p",[e._v("操作 DOM 是很耗费性能的一件事情，既然如此，我们可以考虑通过 JS 对象来模拟 DOM 对象，毕竟操作 JS 对象比操作 DOM 省时的多")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("// 假设这里模拟一个 ul，其中包含了 5 个 li\n[1, 2, 3, 4, 5] \n// 这里替换上面的 li\n[1, 2, 5, 4] \n")])])]),t("p",[e._v("我们一眼就可以看出先前的 ul 中的第三个 li 被移除了，四五替换了位置"),t("br"),e._v("\n如果以上操作对应到 DOM 中,那么就是以下代码"),t("br")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("// 将第四个 li 和第五个交换位置\nlet fromNode = ul.childNodes[4]\nlet toNode = ul.childNodes[3]\n// 删除第三个 li\nul.removeChild(ul.childNodes[2])\n\nlet cloneFromNode = fromNode.cloneNode(true) \nlet cloenToNode = toNode.cloneNode(true)\n// 如果传递给它的参数是 true，它还将递归复制当前节点的所有子孙节点。否则，它只复制当前节点 \n\nul.replaceChild(cloneFromNode, toNode)\nul.replaceChild(cloenToNode, fromNode)\n\n")])])]),t("blockquote",[t("p",[e._v("当然在实际操作中，我们还需要给每个节点一个标识，作为判断是同一个节点的依据。所以这也是 Vue 和 React 中官方推荐列表里的节点使用唯一的 key 来保证性能。")])]),e._v(" "),t("p",[e._v("工具函数：")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("let StateEnums = {\n        ChangeText: 0,\n        ChangeProps: 1,\n        Insert: 2,\n        Move: 3,\n        Remove: 4,\n        Replace: 5\n    }\n\n   function isString(str) {\n        return typeof str === 'string'\n    }\n\n    function move(arr, old_index, new_index) {\n        while (old_index < 0) {\n            old_index += arr.length\n        }\n        while (new_index < 0) {\n            new_index += arr.length\n        }\n        if (new_index >= arr.length) {\n            let k = new_index - arr.length\n            while (k-- + 1) {\n                arr.push(undefined)\n            }\n        }\n        arr.splice(new_index, 0, arr.splice(old_index, 1)[0])\n        return arr\n    } \n")])])]),t("p",[e._v("那么既然 DOM 对象可以通过 JS 对象来模拟，反之也可以通过 JS 对象来渲染出对应的 DOM"),t("br"),e._v("\n以下是一个 JS 对象模拟 DOM 对象的简单实现")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("class Element {\n  /**\n   * @param {String} tag 'div'\n   * @param {Object} props { class: 'item' }\n   * @param {Array} children [ Element1, 'text']\n   * @param {String} key option\n   */\n  constructor(tag, props, children, key) {\n    this.tag = tag\n    this.props = props\n    if (Array.isArray(children)) { // 如果是数组的话 赋值\n      this.children = children\n    } else if (isString(children)) { // 如果是字符串的话就 为空 或者 只有三个参数\n      this.key = children\n      this.children = null\n    }\n    if (key) this.key = key\n  }\n  // 渲染\n  render() {\n    let root = this._createElement(\n      this.tag,\n      this.props,\n      this.children,\n      this.key\n    )\n    document.body.appendChild(root)\n    return root\n  }\n  create() {\n    return this._createElement(this.tag, this.props, this.children, this.key)\n  }\n  // 创建节点\n  _createElement(tag, props, child, key) {\n    // 通过 tag 创建节点\n    let el = document.createElement(tag)\n    // 设置节点属性\n    for (const key in props) { // 遍历对象 \n      if (props.hasOwnProperty(key)) { // 确保key 一定在props 里面\n        const value = props[key]\n        el.setAttribute(key, value)\n      }\n    }\n    if (key) {\n      el.setAttribute('key', key)\n    }\n    // 递归添加子节点\n    if (child) {\n      const that = this;\n      child.forEach(element => {\n        let child\n        if (element instanceof Element) { // 数组里子元素 是继承自Element的话 就再创建一个元素\n          child = that._createElement(\n            element.tag,\n            element.props,\n            element.children,\n            element.key\n          )\n        } else {\n          child = document.createTextNode(element)\n        }\n        el.appendChild(child)\n      })\n    }\n    return el\n  }\n}\nvar b = new Element('p',{class:'text'},['2222'],'name')\n    var a = new Element('div',{class:'text'},[b,'1111'],'name')\n    console.log(a.render()) // 这样页面 就有 新的dom了\n")])])]),t("p",[t("strong",[e._v("Virtual Dom 算法简述")]),t("br"),e._v("\n既然我们已经通过 JS 来模拟实现了 DOM，那么接下来的难点就在于如何判断旧的对象和新的对象之间的差异。"),t("br")]),e._v(" "),t("p",[e._v("DOM 是多叉树的结构，如果需要完整的对比两颗树的差异，那么需要的时间复杂度会是 O(n ^ 3)，这个复杂度肯定是不能接受的。于是 React 团队优化了算法，实现了 O(n) 的复杂度来对比差异。"),t("br")]),e._v(" "),t("p",[e._v("实现 O(n) 复杂度的关键就是只对比同层的节点，而不是跨层对比，这也是考虑到在实际业务中很少会去跨层的移动 DOM 元素。"),t("br")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v(" \x3c!-- 之前 --\x3e\n <div>           \x3c!-- 层级1 --\x3e\n   <p>            \x3c!-- 层级2 --\x3e\n     <b> aoy </b>   \x3c!-- 层级3 --\x3e   \n     <span>diff</Span>\n   </P> \n </div>\n \n \x3c!-- 之后 --\x3e\n <div>            \x3c!-- 层级1 --\x3e\n   <p>             \x3c!-- 层级2 --\x3e\n     <b> aoy </b>        \x3c!-- 层级3 --\x3e\n   </p>\n   <span>diff</Span>\n </div>\n我们可能期望将 <span> 直接移动到 <p> 的后边，这是最优的操作。\n但是实际的diff操作是移除<p> 里的  <span> 在创建一个新的 <span> 插到  <p> 的后边。\n因为新加的 <span> 在层级2，旧的在层级3，属于不同层级的比较。\n")])])]),t("p",[e._v("所以判断差异的算法就分为了两步"),t("br")]),e._v(" "),t("ul",[t("li",[e._v("首先从上至下，从左往右遍历对象，也就是树的深度遍历，这一步中会给每个节点添加索引，便于最后渲染差异")]),e._v(" "),t("li",[e._v("一旦节点有子元素，就去判断子元素是否有不同")])]),e._v(" "),t("h2",{attrs:{id:"virtual-dom-算法实现"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#virtual-dom-算法实现"}},[e._v("#")]),e._v(" Virtual Dom 算法实现")]),e._v(" "),t("p",[t("strong",[e._v("树的递归")]),t("br")]),e._v(" "),t("p",[e._v("首先我们来实现树的递归算法，在实现该算法前，先来考虑下两个节点对比会有几种情况")]),e._v(" "),t("ol",[t("li",[e._v("新的节点的 tagName 或者 key 和旧的不同，这种情况代表需要替换旧的节点，并且也不再需要遍历新旧节点的子元素了，因为整个旧节点都被删掉了")]),e._v(" "),t("li",[e._v("新的节点的 tagName 和 key（可能都没有）和旧的相同，开始遍历子树")]),e._v(" "),t("li",[e._v("没有新的节点，那么什么都不用做")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v(" function diff(oldDomTree, newDomTree){\n         let patches = {}\n         dfs(oldDomTree,newDomTree,0,patches)\n         return patches;\n     }\n     function dfs(oldNode, newNode, index, patches){\n     let curPatches=[];\n     if(!newNode){\n     }else if(newNode.tag === oldNode.tag && newNode.key === oldNode.key){\n         let props = diffProps(oldNode.props, newNode.props);\n         if (props.length) curPatches.push({type:StateEnums.ChangeProps, props})\n         diffChildren(oldNode.children,newNode.children,index,patches)\n     }else{\n         curPatches.push({type:StateEnums.Replace, node:newNode})\n     }\n     if (curPatches.length) {\n         if (patches[index]) {\n             patches[index] = patches[index].concat(curPatches)\n         } else {\n             patches[index] = curPatches\n         }\n     }\n }\n")])])]),t("p",[t("strong",[e._v("判断属性的更改")]),t("br"),e._v("\n判断属性的更改也分三个步骤")]),e._v(" "),t("ol",[t("li",[e._v("遍历旧的属性列表，查看每个属性是否还存在于新的属性列表中")]),e._v(" "),t("li",[e._v("遍历新的属性列表，判断两个列表中都存在的属性的值是否有变化")]),e._v(" "),t("li",[e._v("在第二步中同时查看是否有属性不存在与旧的属性列列表中")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v(" function diffProps(oldProps, newProps){\n         let change =[];\n         for(const key in oldProps){\n             if(oldProps.hasOwnProperty(key) && !newProps[key]){ // 删除了旧属性\n                 change.push({\n                     prop:key\n                 })\n             }\n         }\n         for(const key in newProps){\n             if(newProps.hasOwnProperty(key)){\n                 const prop = newProps[key]\n                 if(oldProps[key] && oldProps[key] !== newProps[key]){ // 修改了属性\n                     change.push({\n                         prop:key,\n                         value:newProps[key]\n                     })\n                 }else if(!oldProps[key]){ // 新增了属性\n                     change.push({\n                         prop:key,\n                         value:newProps[key]\n                     })\n                 }\n             }\n         }\n         return change\n     }\n")])])]),t("p",[t("strong",[e._v("判断列表差异算法实现")]),t("br")]),e._v(" "),t("blockquote",[t("p",[e._v("这个算法是整个 Virtual Dom 中最核心的算法，且让我一一为你道来。 这里的主要步骤其实和判断属性差异是类似的，也是分为三步")])]),e._v(" "),t("ol",[t("li",[e._v("遍历旧的节点列表，查看每个节点是否还存在于新的节点列表中")]),e._v(" "),t("li",[e._v("遍历新的节点列表，判断是否有新的节点")]),e._v(" "),t("li",[e._v("在第二步中同时判断节点是否有移动")])]),e._v(" "),t("p",[e._v("PS: 该算法只对有 key 的节点做处理")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v(" function listDiff(oldList, newList, index, patches){ // 传进来的是children\n         let oldKeys = getKeys(oldList) // oldList newList 就是 一个新的Element\n         let newKeys = getKeys(newList)\n         let changes = [];\n         let list =[];\n         oldList && oldList.forEach(function(item){\n             let key = item.key\n             if(isString(item)){\n                 key = item\n             }\n             let index = newKeys.indexOf(key)\n             if(index === -1){\n                 list.push(null)\n             }else{ list.push(key)}\n         })\n         let length = list.length\n         for(let i =length-1;i>=0;i-- ){\n             if(!list[i]){\n                 list.splice(i,1)\n                 changes.push({\n                     type:StateEnums.Remove,\n                     index:1\n                 })\n             }\n         }\n         newList && newList.forEach(function(item,i){\n             let key = item.key\n             if(isString(item)){\n                 key = item\n             }\n             let index = list.indexOf(key)\n             if(index === -1 || key == null){\n                 changes.push({\n                     type:StateEnums.Insert,\n                     node:item,\n                     index:i,\n                 })\n                 list.splice(i,0,key)\n             }else{\n                 if(index !== i){\n                     changes.push({\n                         type:StateEnums.Move,\n                         from:index,\n                         to:i\n                     })\n                     move(list,index,i)\n                 }\n             }\n         })\n         return {changes:changes,list:list}\n \n     }\n     function getKeys(list){\n         let keys =[]\n          let text;\n         list && list.forEach(function(item){\n             let key;\n             if(isString(item)){\n                 key =[item]\n             }else if(item instanceof Element){\n                 key =item.key\n             }\n             keys.push(key)\n         })\n          return keys;\n      }\n")])])]),t("p",[t("strong",[e._v("遍历子元素打标识")]),t("br"),e._v("\n对于这个函数来说，主要功能就两个")]),e._v(" "),t("ol",[t("li",[e._v("判断两个列表差异")]),e._v(" "),t("li",[e._v("给节点打上标记")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v(" function diffChildren(oldChild,newChild, index, patches){\n         let ld = listDiff(oldChild,newChild, index, patches)\n         console.log(ld)\n         let changes = ld.changes\n         let list =ld.list\n         if(changes.length){\n             if(patches[index]){\n                 patches[index] = patches[index].concat(changes)\n             }else{\n                 patches[index] = changes\n             }\n         }\n         let last = null\n         oldChild && oldChild.forEach(function(item,i){\n             let child = item && item.children\n             if(child){\n                 index = last && last.children ? index + last.children.length + 1 : index + 1\n                 let keyIndex = list.indexOf(item.key)\n                 let node = newChild[keyIndex]\n                 if(node){\n                     dfs(item, node,index,patches)\n                 }\n             }else{\n                 index +=1\n             }\n             last = item\n         })\n     }\n")])])]),t("p",[t("strong",[e._v("渲染差异")]),t("br"),e._v("\n通过之前的算法，我们已经可以得出两个树的差异了。既然知道了差异，就需要局部去更新 DOM 了，下面就让我们来看看 Virtual Dom 算法的最后一步骤\n"),t("br"),e._v("\n这个函数主要两个功能")]),e._v(" "),t("ol",[t("li",[e._v("深度遍历树，将需要做变更操作的取出来")]),e._v(" "),t("li",[e._v("局部更新 DOM")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v(" let index =0\n     function patch(node, patchs){\n         let changes = patchs[index]\n         let childNodes = node && node.childNodes\n         if(!childNodes){\n             index +=1\n         }\n         if (changes && changes.length && patchs[index]) {\n             changeDom(node, changes)\n         }\n         let last = null\n         if (childNodes && childNodes.length) {\n             childNodes.forEach(function(item, i) {\n                 index = last && last.children ? index + last.children.length + 1 : index + 1\n                 patch(item, patchs)\n                 last = item\n             })\n         }\n     }\n \n     function changeDom(node, changes, noChild){\n         changes && changes.forEach(function(change){\n             let { type } = change\n             switch (type){\n                 case StateEnums.ChangeProps:\n                     let {props} = change\n                     props.forEach(function(item){\n                         if(item.value){\n                             node.setAttribute(item.prop,item.value)\n                         }else {\n                             node.removeAttribute(item.prop)\n                         }\n                     })\n                     break;\n                 case StateEnums.Remove:\n                     // ul.removeChild(ul.childNodes[2])\n                     if(node.childNodes[change.index]){\n                         node.removeChild(node.childNodes[change.index])\n                     }\n                     // node.childNodes[change.index].remove()\n                     break\n                 case StateEnums.Insert:\n                     let dom\n                     if (isString(change.node)) {\n                         dom = document.createTextNode(change.node)\n                     } else if (change.node instanceof Element) {\n                         dom = change.node.create()\n                     }\n                     node.insertBefore(dom, node.childNodes[change.index])\n                     break\n                 case StateEnums.Replace:\n                     node.parentNode.replaceChild(change.node.create(), node)\n                     break\n                 case StateEnums.Move:\n                     let fromNode = node.childNodes[change.from]\n                     let toNode = node.childNodes[change.to]\n                     let cloneFromNode = fromNode.cloneNode(true)\n                     let cloenToNode = toNode.cloneNode(true)\n                     node.replaceChild(cloneFromNode, toNode)\n                     node.replaceChild(cloenToNode, fromNode)\n                     break\n                 default:\n                     break\n             }\n         })\n     }\n")])])]),t("p",[t("strong",[e._v("最后")]),t("br"),e._v("\nVirtual Dom 算法的实现也就是以下三步")]),e._v(" "),t("ol",[t("li",[e._v("通过 JS 来模拟创建 DOM 对象")]),e._v(" "),t("li",[e._v("判断两个对象的差异")]),e._v(" "),t("li",[e._v("渲染差异")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("let test4 = new Element('div', { class: 'my-div' }, ['test4'])\n    let test5 = new Element('ul', { class: 'my-div' }, ['test5'])\n\n    let test1 = new Element('div', { class: 'my-div' }, [test4])\n\n    let test2 = new Element('div', { id: '11' }, [test5, test4])\n\n    let root = test1.render()\n\n   console.log(root)\n    let pathchs = diff(test1, test2)\n    console.log(pathchs)\n    setTimeout(function() {\n        console.log('开始更新')\n        patch(root, pathchs)\n        console.log('结束更新')\n    }, 1000) \n")])])])])}),[],!1,null,null,null);n.default=s.exports}}]);