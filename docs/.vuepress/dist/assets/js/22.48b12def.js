(window.webpackJsonp=window.webpackJsonp||[]).push([[22],{109:function(n,e,a){"use strict";a.r(e);var t=a(0),l=Object(t.a)({},(function(){var n=this,e=n.$createElement,a=n._self._c||e;return a("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[a("h2",{attrs:{id:"call-apply-bind"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#call-apply-bind"}},[n._v("#")]),n._v(" call apply bind")]),n._v(" "),a("h2",{attrs:{id:"call"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#call"}},[n._v("#")]),n._v(" call")]),n._v(" "),a("p",[n._v("call和apply作用是一样的，都是为了改变某个函数运行时的上下文（context）而存在的，换句话说，就是为了改变函数体内部this的指向。"),a("br"),n._v("\n作用："),a("br"),n._v("\n使用 call() 方法，您可以编写能够在不同对象上使用的方法"),a("br"),n._v("\n用法：\nA.call(B,x,y)"),a("br"),n._v("\n1  改变函数A的this指向，使之指向B;"),a("br"),n._v("\n2  把A函数放到B中运行，x和y是A函数的"),a("br"),n._v("\n一 常规用法"),a("br"),n._v("\ncall()方法是预定义的js方法 "),a("br"),n._v("\n通过call（）你能够使用属于另一个对象的方法")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v(" var person = {\n      fullName:function(){\n        return this.firstName + '--' + this.lastName\n         }\n     }\n     var person1 = {\n      firstName:'1111',\n       lastName:'2222',\n     }\n     var person2 = {\n      firstName:'3333',\n      lastName:'444',\n     }\n     console.log(person.fullName.call(person1)) //1111--2222\n     console.log(person.fullName.call(person2)) // 3333--444\n")])])]),a("p",[a("a",{attrs:{href:"http://www.zliel.top/vpdemo/js-demo/js-call/call1.html",target:"_blank",rel:"noopener noreferrer"}},[n._v("demo"),a("OutboundLink")],1),n._v(" "),a("br"),n._v("\n2.0 带参数的")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("    var person = {\n      fullName:function(city,age){\n        return this.firstName + '--' + this.lastName +'=' +city+ '年龄'+age\n        }\n    }\n    var person1 = {\n      firstName:'1111',\n      lastName:'2222',\n    }\n    var person2 = {\n      firstName:'3333',\n      lastName:'444',\n    }\n    console.log(person.fullName.call(person1,'郑州','18')) //1111--2222=郑州年龄18\n    console.log(person.fullName.call(person2,'上海','19')) // 3333--444=上海年龄19\n")])])]),a("p",[a("a",{attrs:{href:"http://www.zliel.top/vpdemo/js-demo/js-call/call2.html",target:"_blank",rel:"noopener noreferrer"}},[n._v("demo"),a("OutboundLink")],1),n._v(" "),a("br"),n._v("\n3.0 用来继承")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v(" function Person(){\n  this.sayName = function(){\n    return this.name;\n     }\n }\n\n function Chinese(name){\n  //借助 call 实现继承\n  Person.call(this)\n     this.name = name;\n  this.whichPeople = function(){\n    console.log('我是中国人')\n     }\n }\n var people = new Chinese('小明和')\n console.log(people);\n console.log(people.sayName()) //小明和\n")])])]),a("p",[a("a",{attrs:{href:"http://www.zliel.top/vpdemo/js-demo/js-call/call3.html",target:"_blank",rel:"noopener noreferrer"}},[n._v("demo"),a("OutboundLink")],1),n._v(" "),a("br"),n._v("\n4.0 例1：")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v(" var name = '笑笑';\n    var age  = 17;\n    var obj = {\n    \tname:'打打',\n        objAge:this.age, // 指向上一级作用域 window ，对象不形成作用域\n        myFun:function(){\n    \t\tconsole.log(this.name + '年龄' + this.age);\n        }\n    }\n    console.log(obj.objAge) //17\n    obj.myFun() // 打打年龄undefined\n    var fav = '大爷';\n    function showf(){\n    \tconsole.log(this.fav)\n    }\n    showf();// 大爷\n    比较一下这两者 this 的差别，第一个打印里面的 this 指向 obj，第二个全局声明的 shows() 函数 this 是 window ；\n")])])]),a("p",[a("a",{attrs:{href:"http://www.zliel.top/vpdemo/js-demo/js-call/call4.html",target:"_blank",rel:"noopener noreferrer"}},[n._v("demo"),a("OutboundLink")],1),n._v(" "),a("br")]),n._v(" "),a("p",[n._v("5.0 例2：")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("var name = '笑笑';\n\tvar age  = 17;\n\tvar obj = {\n\t\tname:'打打',\n\t\tobjAge:this.age, // 指向上一级作用域 window ，对象不形成作用域\n\t\tmyFun:function(){\n\t\t\tconsole.log(this.name + '年龄' + this.age);\n\t\t}\n\t}\n\tvar dd = {\n\t\tname:'美女',\n        age:99\n    }\n    obj.myFun.call(dd);// 美女年龄99\n    obj.myFun.apply(dd);// 美女年龄99\n    obj.myFun.bind(dd)();// 美女年龄99\n以上出了 bind 方法后面多了个 () 外 ，结果返回都一致！\n\n由此得出结论，bind 返回的是一个新的函数，你必须调用它才会被执行。\n")])])]),a("p",[a("a",{attrs:{href:"http://www.zliel.top/vpdemo/js-demo/js-call/call5.html",target:"_blank",rel:"noopener noreferrer"}},[n._v("demo"),a("OutboundLink")],1),n._v(" "),a("br"),n._v("\n6.0 例3：")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("var name = '笑笑';\n\tvar age  = 17;\n\tvar obj = {\n\t\tname:'打打',\n\t\tobjAge:this.age, // 指向上一级作用域 window ，对象不形成作用域\n\t\tmyFun:function(fm,t){\n\t\t\tconsole.log(this.name + '年龄' + this.age+'来自'+fm+'的'+t);\n\t\t}\n\t}\n\tvar dd = {\n\t\tname:'美女',\n        age:99\n    }\n    obj.myFun.call(dd,'四川','成都');// 美女年龄99美女年龄99来自四川的成都\n    obj.myFun.apply(dd,['上海','静安区']);// 美女年龄99来自上海的静安区\n\tobj.myFun.bind(dd,'上海','静安区')();// 美女年龄99来自上海静安区的\n    obj.myFun.bind(dd,['上海','静安区'])();// 美女年龄99来自上海,静安区的undefined\n从上面四个结果不难看出:\n\ncall 、bind 、 apply 这三个函数的第一个参数都是 this 的指向对象，第二个参数差别就来了：\n\ncall 的参数是直接放进去的，第二第三第 n 个参数全都用逗号分隔，直接放到后面 obj.myFun.call(db,'成都', ... ,'string' )。\n\napply 的所有参数都必须放在一个数组里面传进去 obj.myFun.apply(db,['成都', ..., 'string' ])。\n\nbind 除了返回是函数以外，它 的参数和 call 一样。\n\n当然，三者的参数不限定是 string 类型，允许是各种类型，包括函数 、 object 等等！\n")])])]),a("p",[a("a",{attrs:{href:"http://www.zliel.top/vpdemo/js-demo/js-call/call6.html",target:"_blank",rel:"noopener noreferrer"}},[n._v("demo"),a("OutboundLink")],1),n._v(" "),a("br")])])}),[],!1,null,null,null);e.default=l.exports}}]);