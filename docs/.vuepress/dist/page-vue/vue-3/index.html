<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>虚拟Dom（Virtual Dom） | 速度至上</title>
    <meta name="generator" content="VuePress 1.4.1">
    <link rel="icon" href="/dist/img/logo.ico">
    <link rel="manifest" href="/dist/manifest.json">
    <meta name="description" content="Reggie Study Notes">
    <link rel="preload" href="/dist/assets/css/0.styles.ad3a04d5.css" as="style"><link rel="preload" href="/dist/assets/js/app.53aea44e.js" as="script"><link rel="preload" href="/dist/assets/js/2.c8eb3e76.js" as="script"><link rel="preload" href="/dist/assets/js/89.c26ab82e.js" as="script"><link rel="prefetch" href="/dist/assets/js/10.99b3fe64.js"><link rel="prefetch" href="/dist/assets/js/11.c100e7aa.js"><link rel="prefetch" href="/dist/assets/js/12.f0d4a132.js"><link rel="prefetch" href="/dist/assets/js/13.bc6a69c8.js"><link rel="prefetch" href="/dist/assets/js/14.6d6162b5.js"><link rel="prefetch" href="/dist/assets/js/15.83d7aa42.js"><link rel="prefetch" href="/dist/assets/js/16.a32089be.js"><link rel="prefetch" href="/dist/assets/js/17.e3b40a13.js"><link rel="prefetch" href="/dist/assets/js/18.1014ffe8.js"><link rel="prefetch" href="/dist/assets/js/19.a37c2571.js"><link rel="prefetch" href="/dist/assets/js/20.149cc93b.js"><link rel="prefetch" href="/dist/assets/js/21.e8b8c4b3.js"><link rel="prefetch" href="/dist/assets/js/22.8de8650b.js"><link rel="prefetch" href="/dist/assets/js/23.d0e3d35b.js"><link rel="prefetch" href="/dist/assets/js/24.2a78a121.js"><link rel="prefetch" href="/dist/assets/js/25.900b32bb.js"><link rel="prefetch" href="/dist/assets/js/26.e5d2f5cd.js"><link rel="prefetch" href="/dist/assets/js/27.a4fa92c2.js"><link rel="prefetch" href="/dist/assets/js/28.7224fe30.js"><link rel="prefetch" href="/dist/assets/js/29.5c45df8b.js"><link rel="prefetch" href="/dist/assets/js/3.eccc0c92.js"><link rel="prefetch" href="/dist/assets/js/30.6dad4003.js"><link rel="prefetch" href="/dist/assets/js/31.6cc52e2a.js"><link rel="prefetch" href="/dist/assets/js/32.d071c597.js"><link rel="prefetch" href="/dist/assets/js/33.effa68bc.js"><link rel="prefetch" href="/dist/assets/js/34.39fa8140.js"><link rel="prefetch" href="/dist/assets/js/35.2939c295.js"><link rel="prefetch" href="/dist/assets/js/36.d11b50f9.js"><link rel="prefetch" href="/dist/assets/js/37.9bdbb1f2.js"><link rel="prefetch" href="/dist/assets/js/38.59c5ecd7.js"><link rel="prefetch" href="/dist/assets/js/39.a7a8037c.js"><link rel="prefetch" href="/dist/assets/js/4.acf22840.js"><link rel="prefetch" href="/dist/assets/js/40.c74438e6.js"><link rel="prefetch" href="/dist/assets/js/41.043a6787.js"><link rel="prefetch" href="/dist/assets/js/42.91479794.js"><link rel="prefetch" href="/dist/assets/js/43.5f1e6d5e.js"><link rel="prefetch" href="/dist/assets/js/44.7f595719.js"><link rel="prefetch" href="/dist/assets/js/45.e6fd0721.js"><link rel="prefetch" href="/dist/assets/js/46.62f0e57f.js"><link rel="prefetch" href="/dist/assets/js/47.53195b37.js"><link rel="prefetch" href="/dist/assets/js/48.531f119d.js"><link rel="prefetch" href="/dist/assets/js/49.482fd7b5.js"><link rel="prefetch" href="/dist/assets/js/5.712f13ff.js"><link rel="prefetch" href="/dist/assets/js/50.3b1397f7.js"><link rel="prefetch" href="/dist/assets/js/51.f896dec0.js"><link rel="prefetch" href="/dist/assets/js/52.085cb00f.js"><link rel="prefetch" href="/dist/assets/js/53.823e478a.js"><link rel="prefetch" href="/dist/assets/js/54.e850c0ec.js"><link rel="prefetch" href="/dist/assets/js/55.23da1051.js"><link rel="prefetch" href="/dist/assets/js/56.811da386.js"><link rel="prefetch" href="/dist/assets/js/57.c8a58ee2.js"><link rel="prefetch" href="/dist/assets/js/58.92097436.js"><link rel="prefetch" href="/dist/assets/js/59.5b3c650f.js"><link rel="prefetch" href="/dist/assets/js/6.a9728e43.js"><link rel="prefetch" href="/dist/assets/js/60.755c497b.js"><link rel="prefetch" href="/dist/assets/js/61.0779fc84.js"><link rel="prefetch" href="/dist/assets/js/62.52528737.js"><link rel="prefetch" href="/dist/assets/js/63.ae780dda.js"><link rel="prefetch" href="/dist/assets/js/64.4f4c8894.js"><link rel="prefetch" href="/dist/assets/js/65.1a99cd65.js"><link rel="prefetch" href="/dist/assets/js/66.dc0711ba.js"><link rel="prefetch" href="/dist/assets/js/67.fe4ca852.js"><link rel="prefetch" href="/dist/assets/js/68.e3350852.js"><link rel="prefetch" href="/dist/assets/js/69.f705a2d7.js"><link rel="prefetch" href="/dist/assets/js/7.6f290f44.js"><link rel="prefetch" href="/dist/assets/js/70.d5b3b9e0.js"><link rel="prefetch" href="/dist/assets/js/71.797daea0.js"><link rel="prefetch" href="/dist/assets/js/72.7bce5541.js"><link rel="prefetch" href="/dist/assets/js/73.b22a9a6b.js"><link rel="prefetch" href="/dist/assets/js/74.d2c35b89.js"><link rel="prefetch" href="/dist/assets/js/75.7e379f64.js"><link rel="prefetch" href="/dist/assets/js/76.854f4694.js"><link rel="prefetch" href="/dist/assets/js/77.0b8b3c74.js"><link rel="prefetch" href="/dist/assets/js/78.e5194eb3.js"><link rel="prefetch" href="/dist/assets/js/79.39bb4c79.js"><link rel="prefetch" href="/dist/assets/js/8.144f56e1.js"><link rel="prefetch" href="/dist/assets/js/80.c5b13a5f.js"><link rel="prefetch" href="/dist/assets/js/81.a6a1661a.js"><link rel="prefetch" href="/dist/assets/js/82.f95f29fd.js"><link rel="prefetch" href="/dist/assets/js/83.f45c0790.js"><link rel="prefetch" href="/dist/assets/js/84.3ce8f8ae.js"><link rel="prefetch" href="/dist/assets/js/85.0af8d964.js"><link rel="prefetch" href="/dist/assets/js/86.ad33b21e.js"><link rel="prefetch" href="/dist/assets/js/87.d70bb385.js"><link rel="prefetch" href="/dist/assets/js/88.fa542aee.js"><link rel="prefetch" href="/dist/assets/js/9.4375f41a.js"><link rel="prefetch" href="/dist/assets/js/90.8640bff5.js"><link rel="prefetch" href="/dist/assets/js/91.f4c9a3e7.js"><link rel="prefetch" href="/dist/assets/js/92.19bdeba2.js"><link rel="prefetch" href="/dist/assets/js/93.55d42cd8.js">
    <link rel="stylesheet" href="/dist/assets/css/0.styles.ad3a04d5.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/dist/" class="home-link router-link-active"><!----> <span class="site-name">速度至上</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/dist/" class="nav-link">
  Home
</a></div><div class="nav-item"><a href="/dist/guide/" class="nav-link">
  Guide
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="Languages" class="dropdown-title"><span class="title">Languages</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/dist/language/chinese.html" class="nav-link">
  Chinese
</a></li><li class="dropdown-item"><!----> <a href="/dist/language/english.html" class="nav-link">
  English
</a></li></ul></div></div><div class="nav-item"><a href="https://www.baidu.com" target="_blank" rel="noopener noreferrer" class="nav-link external">
  External
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/dist/" class="nav-link">
  Home
</a></div><div class="nav-item"><a href="/dist/guide/" class="nav-link">
  Guide
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="Languages" class="dropdown-title"><span class="title">Languages</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/dist/language/chinese.html" class="nav-link">
  Chinese
</a></li><li class="dropdown-item"><!----> <a href="/dist/language/english.html" class="nav-link">
  English
</a></li></ul></div></div><div class="nav-item"><a href="https://www.baidu.com" target="_blank" rel="noopener noreferrer" class="nav-link external">
  External
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>node</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>js知识点</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>js杂项知识点</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>js设计模式</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>js函数（方法）</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>有待学习的</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>HTML</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>CSS</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>JS</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>VUE</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/dist/page-vue/vue-1/" class="sidebar-link">vue 知识点1</a></li><li><a href="/dist/page-vue/vue-2/" class="sidebar-link">vue面试题</a></li><li><a href="/dist/page-vue/vue-3/" class="active sidebar-link">虚拟Dom（Virtual Dom）</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/dist/page-vue/vue-3/#虚拟dom（virtual-dom）" class="sidebar-link">虚拟Dom（Virtual Dom）</a></li><li class="sidebar-sub-header"><a href="/dist/page-vue/vue-3/#virtual-dom-算法实现" class="sidebar-link">Virtual Dom 算法实现</a></li></ul></li><li><a href="/dist/page-vue/vue-4/" class="sidebar-link">Vuex实战</a></li><li><a href="/dist/page-vue/vue-5/" class="sidebar-link">Vue Router(路由)</a></li><li><a href="/dist/page-vue/vue-6/" class="sidebar-link">vue权限控制之路由动态加载</a></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>HTTP</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>es6相关</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Git</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>webpack</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>英语单词</span> <span class="arrow right"></span></p> <!----></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h2 id="虚拟dom（virtual-dom）"><a href="#虚拟dom（virtual-dom）" class="header-anchor">#</a> 虚拟Dom（Virtual Dom）</h2> <p>操作 DOM 是很耗费性能的一件事情，既然如此，我们可以考虑通过 JS 对象来模拟 DOM 对象，毕竟操作 JS 对象比操作 DOM 省时的多</p> <div class="language- extra-class"><pre class="language-text"><code>// 假设这里模拟一个 ul，其中包含了 5 个 li
[1, 2, 3, 4, 5] 
// 这里替换上面的 li
[1, 2, 5, 4] 
</code></pre></div><p>我们一眼就可以看出先前的 ul 中的第三个 li 被移除了，四五替换了位置<br>
如果以上操作对应到 DOM 中,那么就是以下代码<br></p> <div class="language- extra-class"><pre class="language-text"><code>// 将第四个 li 和第五个交换位置
let fromNode = ul.childNodes[4]
let toNode = ul.childNodes[3]
// 删除第三个 li
ul.removeChild(ul.childNodes[2])

let cloneFromNode = fromNode.cloneNode(true) 
let cloenToNode = toNode.cloneNode(true)
// 如果传递给它的参数是 true，它还将递归复制当前节点的所有子孙节点。否则，它只复制当前节点 

ul.replaceChild(cloneFromNode, toNode)
ul.replaceChild(cloenToNode, fromNode)

</code></pre></div><blockquote><p>当然在实际操作中，我们还需要给每个节点一个标识，作为判断是同一个节点的依据。所以这也是 Vue 和 React 中官方推荐列表里的节点使用唯一的 key 来保证性能。</p></blockquote> <p>工具函数：</p> <div class="language- extra-class"><pre class="language-text"><code>let StateEnums = {
        ChangeText: 0,
        ChangeProps: 1,
        Insert: 2,
        Move: 3,
        Remove: 4,
        Replace: 5
    }

   function isString(str) {
        return typeof str === 'string'
    }

    function move(arr, old_index, new_index) {
        while (old_index &lt; 0) {
            old_index += arr.length
        }
        while (new_index &lt; 0) {
            new_index += arr.length
        }
        if (new_index &gt;= arr.length) {
            let k = new_index - arr.length
            while (k-- + 1) {
                arr.push(undefined)
            }
        }
        arr.splice(new_index, 0, arr.splice(old_index, 1)[0])
        return arr
    } 
</code></pre></div><p>那么既然 DOM 对象可以通过 JS 对象来模拟，反之也可以通过 JS 对象来渲染出对应的 DOM<br>
以下是一个 JS 对象模拟 DOM 对象的简单实现</p> <div class="language- extra-class"><pre class="language-text"><code>class Element {
  /**
   * @param {String} tag 'div'
   * @param {Object} props { class: 'item' }
   * @param {Array} children [ Element1, 'text']
   * @param {String} key option
   */
  constructor(tag, props, children, key) {
    this.tag = tag
    this.props = props
    if (Array.isArray(children)) { // 如果是数组的话 赋值
      this.children = children
    } else if (isString(children)) { // 如果是字符串的话就 为空 或者 只有三个参数
      this.key = children
      this.children = null
    }
    if (key) this.key = key
  }
  // 渲染
  render() {
    let root = this._createElement(
      this.tag,
      this.props,
      this.children,
      this.key
    )
    document.body.appendChild(root)
    return root
  }
  create() {
    return this._createElement(this.tag, this.props, this.children, this.key)
  }
  // 创建节点
  _createElement(tag, props, child, key) {
    // 通过 tag 创建节点
    let el = document.createElement(tag)
    // 设置节点属性
    for (const key in props) { // 遍历对象 
      if (props.hasOwnProperty(key)) { // 确保key 一定在props 里面
        const value = props[key]
        el.setAttribute(key, value)
      }
    }
    if (key) {
      el.setAttribute('key', key)
    }
    // 递归添加子节点
    if (child) {
      const that = this;
      child.forEach(element =&gt; {
        let child
        if (element instanceof Element) { // 数组里子元素 是继承自Element的话 就再创建一个元素
          child = that._createElement(
            element.tag,
            element.props,
            element.children,
            element.key
          )
        } else {
          child = document.createTextNode(element)
        }
        el.appendChild(child)
      })
    }
    return el
  }
}
var b = new Element('p',{class:'text'},['2222'],'name')
    var a = new Element('div',{class:'text'},[b,'1111'],'name')
    console.log(a.render()) // 这样页面 就有 新的dom了
</code></pre></div><p><strong>Virtual Dom 算法简述</strong><br>
既然我们已经通过 JS 来模拟实现了 DOM，那么接下来的难点就在于如何判断旧的对象和新的对象之间的差异。<br></p> <p>DOM 是多叉树的结构，如果需要完整的对比两颗树的差异，那么需要的时间复杂度会是 O(n ^ 3)，这个复杂度肯定是不能接受的。于是 React 团队优化了算法，实现了 O(n) 的复杂度来对比差异。<br></p> <p>实现 O(n) 复杂度的关键就是只对比同层的节点，而不是跨层对比，这也是考虑到在实际业务中很少会去跨层的移动 DOM 元素。<br></p> <div class="language- extra-class"><pre class="language-text"><code> &lt;!-- 之前 --&gt;
 &lt;div&gt;           &lt;!-- 层级1 --&gt;
   &lt;p&gt;            &lt;!-- 层级2 --&gt;
     &lt;b&gt; aoy &lt;/b&gt;   &lt;!-- 层级3 --&gt;   
     &lt;span&gt;diff&lt;/Span&gt;
   &lt;/P&gt; 
 &lt;/div&gt;
 
 &lt;!-- 之后 --&gt;
 &lt;div&gt;            &lt;!-- 层级1 --&gt;
   &lt;p&gt;             &lt;!-- 层级2 --&gt;
     &lt;b&gt; aoy &lt;/b&gt;        &lt;!-- 层级3 --&gt;
   &lt;/p&gt;
   &lt;span&gt;diff&lt;/Span&gt;
 &lt;/div&gt;
我们可能期望将 &lt;span&gt; 直接移动到 &lt;p&gt; 的后边，这是最优的操作。
但是实际的diff操作是移除&lt;p&gt; 里的  &lt;span&gt; 在创建一个新的 &lt;span&gt; 插到  &lt;p&gt; 的后边。
因为新加的 &lt;span&gt; 在层级2，旧的在层级3，属于不同层级的比较。
</code></pre></div><p>所以判断差异的算法就分为了两步<br></p> <ul><li>首先从上至下，从左往右遍历对象，也就是树的深度遍历，这一步中会给每个节点添加索引，便于最后渲染差异</li> <li>一旦节点有子元素，就去判断子元素是否有不同</li></ul> <h2 id="virtual-dom-算法实现"><a href="#virtual-dom-算法实现" class="header-anchor">#</a> Virtual Dom 算法实现</h2> <p><strong>树的递归</strong><br></p> <p>首先我们来实现树的递归算法，在实现该算法前，先来考虑下两个节点对比会有几种情况</p> <ol><li>新的节点的 tagName 或者 key 和旧的不同，这种情况代表需要替换旧的节点，并且也不再需要遍历新旧节点的子元素了，因为整个旧节点都被删掉了</li> <li>新的节点的 tagName 和 key（可能都没有）和旧的相同，开始遍历子树</li> <li>没有新的节点，那么什么都不用做</li></ol> <div class="language- extra-class"><pre class="language-text"><code> function diff(oldDomTree, newDomTree){
         let patches = {}
         dfs(oldDomTree,newDomTree,0,patches)
         return patches;
     }
     function dfs(oldNode, newNode, index, patches){
     let curPatches=[];
     if(!newNode){
     }else if(newNode.tag === oldNode.tag &amp;&amp; newNode.key === oldNode.key){
         let props = diffProps(oldNode.props, newNode.props);
         if (props.length) curPatches.push({type:StateEnums.ChangeProps, props})
         diffChildren(oldNode.children,newNode.children,index,patches)
     }else{
         curPatches.push({type:StateEnums.Replace, node:newNode})
     }
     if (curPatches.length) {
         if (patches[index]) {
             patches[index] = patches[index].concat(curPatches)
         } else {
             patches[index] = curPatches
         }
     }
 }
</code></pre></div><p><strong>判断属性的更改</strong><br>
判断属性的更改也分三个步骤</p> <ol><li>遍历旧的属性列表，查看每个属性是否还存在于新的属性列表中</li> <li>遍历新的属性列表，判断两个列表中都存在的属性的值是否有变化</li> <li>在第二步中同时查看是否有属性不存在与旧的属性列列表中</li></ol> <div class="language- extra-class"><pre class="language-text"><code> function diffProps(oldProps, newProps){
         let change =[];
         for(const key in oldProps){
             if(oldProps.hasOwnProperty(key) &amp;&amp; !newProps[key]){ // 删除了旧属性
                 change.push({
                     prop:key
                 })
             }
         }
         for(const key in newProps){
             if(newProps.hasOwnProperty(key)){
                 const prop = newProps[key]
                 if(oldProps[key] &amp;&amp; oldProps[key] !== newProps[key]){ // 修改了属性
                     change.push({
                         prop:key,
                         value:newProps[key]
                     })
                 }else if(!oldProps[key]){ // 新增了属性
                     change.push({
                         prop:key,
                         value:newProps[key]
                     })
                 }
             }
         }
         return change
     }
</code></pre></div><p><strong>判断列表差异算法实现</strong><br></p> <blockquote><p>这个算法是整个 Virtual Dom 中最核心的算法，且让我一一为你道来。 这里的主要步骤其实和判断属性差异是类似的，也是分为三步</p></blockquote> <ol><li>遍历旧的节点列表，查看每个节点是否还存在于新的节点列表中</li> <li>遍历新的节点列表，判断是否有新的节点</li> <li>在第二步中同时判断节点是否有移动</li></ol> <p>PS: 该算法只对有 key 的节点做处理</p> <div class="language- extra-class"><pre class="language-text"><code> function listDiff(oldList, newList, index, patches){ // 传进来的是children
         let oldKeys = getKeys(oldList) // oldList newList 就是 一个新的Element
         let newKeys = getKeys(newList)
         let changes = [];
         let list =[];
         oldList &amp;&amp; oldList.forEach(function(item){
             let key = item.key
             if(isString(item)){
                 key = item
             }
             let index = newKeys.indexOf(key)
             if(index === -1){
                 list.push(null)
             }else{ list.push(key)}
         })
         let length = list.length
         for(let i =length-1;i&gt;=0;i-- ){
             if(!list[i]){
                 list.splice(i,1)
                 changes.push({
                     type:StateEnums.Remove,
                     index:1
                 })
             }
         }
         newList &amp;&amp; newList.forEach(function(item,i){
             let key = item.key
             if(isString(item)){
                 key = item
             }
             let index = list.indexOf(key)
             if(index === -1 || key == null){
                 changes.push({
                     type:StateEnums.Insert,
                     node:item,
                     index:i,
                 })
                 list.splice(i,0,key)
             }else{
                 if(index !== i){
                     changes.push({
                         type:StateEnums.Move,
                         from:index,
                         to:i
                     })
                     move(list,index,i)
                 }
             }
         })
         return {changes:changes,list:list}
 
     }
     function getKeys(list){
         let keys =[]
          let text;
         list &amp;&amp; list.forEach(function(item){
             let key;
             if(isString(item)){
                 key =[item]
             }else if(item instanceof Element){
                 key =item.key
             }
             keys.push(key)
         })
          return keys;
      }
</code></pre></div><p><strong>遍历子元素打标识</strong><br>
对于这个函数来说，主要功能就两个</p> <ol><li>判断两个列表差异</li> <li>给节点打上标记</li></ol> <div class="language- extra-class"><pre class="language-text"><code> function diffChildren(oldChild,newChild, index, patches){
         let ld = listDiff(oldChild,newChild, index, patches)
         console.log(ld)
         let changes = ld.changes
         let list =ld.list
         if(changes.length){
             if(patches[index]){
                 patches[index] = patches[index].concat(changes)
             }else{
                 patches[index] = changes
             }
         }
         let last = null
         oldChild &amp;&amp; oldChild.forEach(function(item,i){
             let child = item &amp;&amp; item.children
             if(child){
                 index = last &amp;&amp; last.children ? index + last.children.length + 1 : index + 1
                 let keyIndex = list.indexOf(item.key)
                 let node = newChild[keyIndex]
                 if(node){
                     dfs(item, node,index,patches)
                 }
             }else{
                 index +=1
             }
             last = item
         })
     }
</code></pre></div><p><strong>渲染差异</strong><br>
通过之前的算法，我们已经可以得出两个树的差异了。既然知道了差异，就需要局部去更新 DOM 了，下面就让我们来看看 Virtual Dom 算法的最后一步骤
<br>
这个函数主要两个功能</p> <ol><li>深度遍历树，将需要做变更操作的取出来</li> <li>局部更新 DOM</li></ol> <div class="language- extra-class"><pre class="language-text"><code> let index =0
     function patch(node, patchs){
         let changes = patchs[index]
         let childNodes = node &amp;&amp; node.childNodes
         if(!childNodes){
             index +=1
         }
         if (changes &amp;&amp; changes.length &amp;&amp; patchs[index]) {
             changeDom(node, changes)
         }
         let last = null
         if (childNodes &amp;&amp; childNodes.length) {
             childNodes.forEach(function(item, i) {
                 index = last &amp;&amp; last.children ? index + last.children.length + 1 : index + 1
                 patch(item, patchs)
                 last = item
             })
         }
     }
 
     function changeDom(node, changes, noChild){
         changes &amp;&amp; changes.forEach(function(change){
             let { type } = change
             switch (type){
                 case StateEnums.ChangeProps:
                     let {props} = change
                     props.forEach(function(item){
                         if(item.value){
                             node.setAttribute(item.prop,item.value)
                         }else {
                             node.removeAttribute(item.prop)
                         }
                     })
                     break;
                 case StateEnums.Remove:
                     // ul.removeChild(ul.childNodes[2])
                     if(node.childNodes[change.index]){
                         node.removeChild(node.childNodes[change.index])
                     }
                     // node.childNodes[change.index].remove()
                     break
                 case StateEnums.Insert:
                     let dom
                     if (isString(change.node)) {
                         dom = document.createTextNode(change.node)
                     } else if (change.node instanceof Element) {
                         dom = change.node.create()
                     }
                     node.insertBefore(dom, node.childNodes[change.index])
                     break
                 case StateEnums.Replace:
                     node.parentNode.replaceChild(change.node.create(), node)
                     break
                 case StateEnums.Move:
                     let fromNode = node.childNodes[change.from]
                     let toNode = node.childNodes[change.to]
                     let cloneFromNode = fromNode.cloneNode(true)
                     let cloenToNode = toNode.cloneNode(true)
                     node.replaceChild(cloneFromNode, toNode)
                     node.replaceChild(cloenToNode, fromNode)
                     break
                 default:
                     break
             }
         })
     }
</code></pre></div><p><strong>最后</strong><br>
Virtual Dom 算法的实现也就是以下三步</p> <ol><li>通过 JS 来模拟创建 DOM 对象</li> <li>判断两个对象的差异</li> <li>渲染差异</li></ol> <div class="language- extra-class"><pre class="language-text"><code>let test4 = new Element('div', { class: 'my-div' }, ['test4'])
    let test5 = new Element('ul', { class: 'my-div' }, ['test5'])

    let test1 = new Element('div', { class: 'my-div' }, [test4])

    let test2 = new Element('div', { id: '11' }, [test5, test4])

    let root = test1.render()

   console.log(root)
    let pathchs = diff(test1, test2)
    console.log(pathchs)
    setTimeout(function() {
        console.log('开始更新')
        patch(root, pathchs)
        console.log('结束更新')
    }, 1000) 
</code></pre></div></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/dist/page-vue/vue-2/" class="prev">
        vue面试题
      </a></span> <span class="next"><a href="/dist/page-vue/vue-4/">
        Vuex实战
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/dist/assets/js/app.53aea44e.js" defer></script><script src="/dist/assets/js/2.c8eb3e76.js" defer></script><script src="/dist/assets/js/89.c26ab82e.js" defer></script>
  </body>
</html>
