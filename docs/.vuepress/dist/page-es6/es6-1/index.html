<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>es6 相关知识点 | 速度至上</title>
    <meta name="generator" content="VuePress 1.4.1">
    <link rel="icon" href="/dist/img/logo.ico">
    <link rel="manifest" href="/dist/manifest.json">
    <meta name="description" content="Reggie Study Notes">
    <link rel="preload" href="/dist/assets/css/0.styles.ad3a04d5.css" as="style"><link rel="preload" href="/dist/assets/js/app.d79bc38e.js" as="script"><link rel="preload" href="/dist/assets/js/2.a6a1bbd9.js" as="script"><link rel="preload" href="/dist/assets/js/49.83c72d63.js" as="script"><link rel="prefetch" href="/dist/assets/js/10.6f1128cd.js"><link rel="prefetch" href="/dist/assets/js/100.11170ca4.js"><link rel="prefetch" href="/dist/assets/js/101.df4256bb.js"><link rel="prefetch" href="/dist/assets/js/102.73c0978a.js"><link rel="prefetch" href="/dist/assets/js/103.c3f70e3b.js"><link rel="prefetch" href="/dist/assets/js/104.80e8d438.js"><link rel="prefetch" href="/dist/assets/js/105.7fcc574d.js"><link rel="prefetch" href="/dist/assets/js/106.f2b6dd5e.js"><link rel="prefetch" href="/dist/assets/js/107.387c438d.js"><link rel="prefetch" href="/dist/assets/js/108.84876aec.js"><link rel="prefetch" href="/dist/assets/js/109.be9663a4.js"><link rel="prefetch" href="/dist/assets/js/11.f0b2e5ad.js"><link rel="prefetch" href="/dist/assets/js/110.6fc9fd7b.js"><link rel="prefetch" href="/dist/assets/js/111.f0f30997.js"><link rel="prefetch" href="/dist/assets/js/12.5f83c13d.js"><link rel="prefetch" href="/dist/assets/js/13.5302d541.js"><link rel="prefetch" href="/dist/assets/js/14.6d385b49.js"><link rel="prefetch" href="/dist/assets/js/15.180126ec.js"><link rel="prefetch" href="/dist/assets/js/16.279dd344.js"><link rel="prefetch" href="/dist/assets/js/17.b3411b71.js"><link rel="prefetch" href="/dist/assets/js/18.df40f619.js"><link rel="prefetch" href="/dist/assets/js/19.3d5204a0.js"><link rel="prefetch" href="/dist/assets/js/20.9529900c.js"><link rel="prefetch" href="/dist/assets/js/21.d5e6a04b.js"><link rel="prefetch" href="/dist/assets/js/22.c2f2de64.js"><link rel="prefetch" href="/dist/assets/js/23.65cd84c0.js"><link rel="prefetch" href="/dist/assets/js/24.d195bc64.js"><link rel="prefetch" href="/dist/assets/js/25.00e36db3.js"><link rel="prefetch" href="/dist/assets/js/26.82157dcf.js"><link rel="prefetch" href="/dist/assets/js/27.d423e5b0.js"><link rel="prefetch" href="/dist/assets/js/28.6af5f0cc.js"><link rel="prefetch" href="/dist/assets/js/29.a789eb6b.js"><link rel="prefetch" href="/dist/assets/js/3.41915d9e.js"><link rel="prefetch" href="/dist/assets/js/30.a2c5a2b3.js"><link rel="prefetch" href="/dist/assets/js/31.b5837568.js"><link rel="prefetch" href="/dist/assets/js/32.c0e493bb.js"><link rel="prefetch" href="/dist/assets/js/33.6876c260.js"><link rel="prefetch" href="/dist/assets/js/34.c963248f.js"><link rel="prefetch" href="/dist/assets/js/35.793f7af6.js"><link rel="prefetch" href="/dist/assets/js/36.359336bf.js"><link rel="prefetch" href="/dist/assets/js/37.e4288439.js"><link rel="prefetch" href="/dist/assets/js/38.f187f4aa.js"><link rel="prefetch" href="/dist/assets/js/39.d59b15d2.js"><link rel="prefetch" href="/dist/assets/js/4.d2c0f82f.js"><link rel="prefetch" href="/dist/assets/js/40.c0e8642a.js"><link rel="prefetch" href="/dist/assets/js/41.417cec39.js"><link rel="prefetch" href="/dist/assets/js/42.e67adf7d.js"><link rel="prefetch" href="/dist/assets/js/43.b0c59c1d.js"><link rel="prefetch" href="/dist/assets/js/44.844d5752.js"><link rel="prefetch" href="/dist/assets/js/45.1688c285.js"><link rel="prefetch" href="/dist/assets/js/46.c938498a.js"><link rel="prefetch" href="/dist/assets/js/47.d16a2de7.js"><link rel="prefetch" href="/dist/assets/js/48.0f6ccef5.js"><link rel="prefetch" href="/dist/assets/js/5.eef27408.js"><link rel="prefetch" href="/dist/assets/js/50.d75aa61b.js"><link rel="prefetch" href="/dist/assets/js/51.7a3fc515.js"><link rel="prefetch" href="/dist/assets/js/52.964c0d40.js"><link rel="prefetch" href="/dist/assets/js/53.6e60e28c.js"><link rel="prefetch" href="/dist/assets/js/54.5531b960.js"><link rel="prefetch" href="/dist/assets/js/55.c61acf00.js"><link rel="prefetch" href="/dist/assets/js/56.e7d0f61d.js"><link rel="prefetch" href="/dist/assets/js/57.0bd4a98c.js"><link rel="prefetch" href="/dist/assets/js/58.96197d13.js"><link rel="prefetch" href="/dist/assets/js/59.67effb16.js"><link rel="prefetch" href="/dist/assets/js/6.3e0d7e62.js"><link rel="prefetch" href="/dist/assets/js/60.a6e7f59c.js"><link rel="prefetch" href="/dist/assets/js/61.9a50da49.js"><link rel="prefetch" href="/dist/assets/js/62.c7cd0bab.js"><link rel="prefetch" href="/dist/assets/js/63.65162c49.js"><link rel="prefetch" href="/dist/assets/js/64.4bc8c61b.js"><link rel="prefetch" href="/dist/assets/js/65.39864fc0.js"><link rel="prefetch" href="/dist/assets/js/66.11ecd0d0.js"><link rel="prefetch" href="/dist/assets/js/67.b24d0a8f.js"><link rel="prefetch" href="/dist/assets/js/68.908c8aa2.js"><link rel="prefetch" href="/dist/assets/js/69.308baca4.js"><link rel="prefetch" href="/dist/assets/js/7.64ed6c1b.js"><link rel="prefetch" href="/dist/assets/js/70.a9ad4f9b.js"><link rel="prefetch" href="/dist/assets/js/71.4fb4daef.js"><link rel="prefetch" href="/dist/assets/js/72.e9061cad.js"><link rel="prefetch" href="/dist/assets/js/73.5b57c759.js"><link rel="prefetch" href="/dist/assets/js/74.7177e34d.js"><link rel="prefetch" href="/dist/assets/js/75.b9757d9a.js"><link rel="prefetch" href="/dist/assets/js/76.8e17deca.js"><link rel="prefetch" href="/dist/assets/js/77.b80787b3.js"><link rel="prefetch" href="/dist/assets/js/78.a06065c1.js"><link rel="prefetch" href="/dist/assets/js/79.f4fe4f81.js"><link rel="prefetch" href="/dist/assets/js/8.ba3e1811.js"><link rel="prefetch" href="/dist/assets/js/80.52c9f2d0.js"><link rel="prefetch" href="/dist/assets/js/81.a547eb77.js"><link rel="prefetch" href="/dist/assets/js/82.803609b2.js"><link rel="prefetch" href="/dist/assets/js/83.3971ea93.js"><link rel="prefetch" href="/dist/assets/js/84.ad2251d2.js"><link rel="prefetch" href="/dist/assets/js/85.0a3a1c82.js"><link rel="prefetch" href="/dist/assets/js/86.ef50644d.js"><link rel="prefetch" href="/dist/assets/js/87.591ab72e.js"><link rel="prefetch" href="/dist/assets/js/88.95bd02d7.js"><link rel="prefetch" href="/dist/assets/js/89.e886825f.js"><link rel="prefetch" href="/dist/assets/js/9.e8c6ade8.js"><link rel="prefetch" href="/dist/assets/js/90.81128d8d.js"><link rel="prefetch" href="/dist/assets/js/91.39a085a4.js"><link rel="prefetch" href="/dist/assets/js/92.3abf3774.js"><link rel="prefetch" href="/dist/assets/js/93.83d6f081.js"><link rel="prefetch" href="/dist/assets/js/94.225523c5.js"><link rel="prefetch" href="/dist/assets/js/95.d223e4e7.js"><link rel="prefetch" href="/dist/assets/js/96.0b2eb068.js"><link rel="prefetch" href="/dist/assets/js/97.e5459491.js"><link rel="prefetch" href="/dist/assets/js/98.367e8e8f.js"><link rel="prefetch" href="/dist/assets/js/99.f4c11ed0.js">
    <link rel="stylesheet" href="/dist/assets/css/0.styles.ad3a04d5.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/dist/" class="home-link router-link-active"><!----> <span class="site-name">速度至上</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/dist/" class="nav-link">
  Home
</a></div><div class="nav-item"><a href="/dist/guide/" class="nav-link">
  Guide
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="Languages" class="dropdown-title"><span class="title">Languages</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/dist/language/chinese.html" class="nav-link">
  Chinese
</a></li><li class="dropdown-item"><!----> <a href="/dist/language/english.html" class="nav-link">
  English
</a></li></ul></div></div><div class="nav-item"><a href="https://www.baidu.com" target="_blank" rel="noopener noreferrer" class="nav-link external">
  External
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/dist/" class="nav-link">
  Home
</a></div><div class="nav-item"><a href="/dist/guide/" class="nav-link">
  Guide
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="Languages" class="dropdown-title"><span class="title">Languages</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/dist/language/chinese.html" class="nav-link">
  Chinese
</a></li><li class="dropdown-item"><!----> <a href="/dist/language/english.html" class="nav-link">
  English
</a></li></ul></div></div><div class="nav-item"><a href="https://www.baidu.com" target="_blank" rel="noopener noreferrer" class="nav-link external">
  External
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>node</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>js知识点</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>js杂项知识点</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>js设计模式</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>js函数（方法）</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>有待学习的</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>HTML</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>CSS</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>JS</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>VUE</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>HTTP</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>es6相关</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/dist/page-es6/es6-1/" class="active sidebar-link">es6 相关知识点</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/dist/page-es6/es6-1/#es6-相关知识点" class="sidebar-link">es6 相关知识点</a></li><li class="sidebar-sub-header"><a href="/dist/page-es6/es6-1/#_1-0-解构赋值" class="sidebar-link">1.0 解构赋值</a></li><li class="sidebar-sub-header"><a href="/dist/page-es6/es6-1/#_3-0-promise" class="sidebar-link">3.0 promise</a></li><li class="sidebar-sub-header"><a href="/dist/page-es6/es6-1/#generator" class="sidebar-link">Generator</a></li><li class="sidebar-sub-header"><a href="/dist/page-es6/es6-1/#_4-0-async" class="sidebar-link">4.0 async</a></li><li class="sidebar-sub-header"><a href="/dist/page-es6/es6-1/#_5-0-函数" class="sidebar-link">5.0 函数</a></li><li class="sidebar-sub-header"><a href="/dist/page-es6/es6-1/#_4-0-symbol-数据类型" class="sidebar-link">4.0 Symbol 数据类型</a></li><li class="sidebar-sub-header"><a href="/dist/page-es6/es6-1/#_5-0-set-对象-和map对象" class="sidebar-link">5.0 Set 对象 和map对象</a></li><li class="sidebar-sub-header"><a href="/dist/page-es6/es6-1/#_6-0-es6-reflect-与-proxy" class="sidebar-link">6.0 ES6 Reflect 与 Proxy</a></li><li class="sidebar-sub-header"><a href="/dist/page-es6/es6-1/#_7-0-es6-迭代器" class="sidebar-link">7.0 ES6 迭代器</a></li></ul></li><li><a href="/dist/page-es6/es6-2/" class="sidebar-link">es6 相关知识点2</a></li><li><a href="/dist/page-es6/es6-3/" class="sidebar-link">Promise</a></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Git</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>webpack</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>数据结构与算法</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>javaScript函数式编程（美）</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>英语单词</span> <span class="arrow right"></span></p> <!----></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h2 id="es6-相关知识点"><a href="#es6-相关知识点" class="header-anchor">#</a> es6 相关知识点</h2> <h2 id="_1-0-解构赋值"><a href="#_1-0-解构赋值" class="header-anchor">#</a> 1.0 解构赋值</h2> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">let</span> <span class="token punctuation">[</span>a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> c<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span>

不完全解构
<span class="token keyword">let</span> <span class="token punctuation">[</span>a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span> b<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment">// a = 1, b = undefined</span>

剩余运算符
<span class="token keyword">let</span> <span class="token punctuation">[</span>a<span class="token punctuation">,</span> <span class="token operator">...</span>b<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span> 
<span class="token comment">//a = 1</span>
<span class="token comment">//b = [2, 3]</span>

对象模型的解构
 <span class="token keyword">let</span> <span class="token punctuation">{</span> foo<span class="token punctuation">,</span> bar <span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token punctuation">{</span> foo<span class="token operator">:</span> <span class="token string">'aaa'</span><span class="token punctuation">,</span> bar<span class="token operator">:</span> <span class="token string">'bbb'</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>

解构默认值
<span class="token keyword">let</span> <span class="token punctuation">{</span>a <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">,</span> b <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token punctuation">{</span>a<span class="token operator">:</span> <span class="token number">3</span><span class="token punctuation">}</span><span class="token punctuation">;</span>

深层次解构
<span class="token keyword">let</span> <span class="token punctuation">{</span>data<span class="token operator">:</span><span class="token punctuation">[</span>list<span class="token punctuation">]</span><span class="token punctuation">,</span>status<span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token punctuation">{</span>data<span class="token operator">:</span><span class="token punctuation">[</span><span class="token punctuation">{</span>name<span class="token operator">:</span><span class="token string">'1'</span><span class="token punctuation">}</span><span class="token punctuation">]</span><span class="token punctuation">,</span>status<span class="token operator">:</span><span class="token number">0</span><span class="token punctuation">}</span>
list <span class="token comment">// [{name:'1'}]</span>
</code></pre></div><h2 id="_3-0-promise"><a href="#_3-0-promise" class="header-anchor">#</a> 3.0 promise</h2> <p>是异步编程的一种解决方案。<br></p> <p>从语法上说，Promise 是一个对象，从它可以获取异步操作的消息。<br></p> <p><strong>状态的特点</strong><br>
Promise 异步操作有三种状态：pending（进行中）、fulfilled（已成功）和 rejected（已失败）。除了异步操作的结果，任何其他操作都无法改变这个状态。
<br>
Promise 对象只有：从 pending 变为 fulfilled 和从 pending 变为 rejected 的状态改变。只要处于 fulfilled 和 rejected ，状态就不会再变了即 resolved（已定型）。<br></p> <p><strong>状态的缺点</strong><br>
无法取消 Promise ，一旦新建它就会立即执行，无法中途取消。
<br>
如果不设置回调函数，Promise 内部抛出的错误，不会反应到外部。
<br>
当处于 pending 状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）。
<br></p> <h2 id="generator"><a href="#generator" class="header-anchor">#</a> Generator</h2> <p>ES6 新引入了 Generator 函数，可以通过 yield 关键字，把函数的执行流挂起，为改变执行流程提供了可能，从而为异步编程提供解决方案。 基本用法</p> <h2 id="_4-0-async"><a href="#_4-0-async" class="header-anchor">#</a> 4.0 async</h2> <p>async 函数返回一个 Promise 对象，可以使用 then 方法添加回调函数。</p> <div class="language- extra-class"><pre class="language-text"><code> function testAwait(){
    return new Promise((resolve) =&gt; {
        setTimeout(function(){
           console.log(&quot;testAwait&quot;);
           resolve();
        }, 1000);
    });
 }
  
 async function helloAsync(){
    await testAwait();
    console.log(&quot;helloAsync&quot;);
  }
 helloAsync();
 // testAwait
 // helloAsync
</code></pre></div><p>await 关键字仅在 async function 中有效。如果在 async function 函数体外使用 await ，你只会得到一个语法错误。</p> <h2 id="_5-0-函数"><a href="#_5-0-函数" class="header-anchor">#</a> 5.0 函数</h2> <div class="language- extra-class"><pre class="language-text"><code> 1.0 函数参数的扩展  默认参数
function fn(name,age=17){
 console.log(name+&quot;,&quot;+age);
}
fn(&quot;Amy&quot;,18);  // Amy,18
fn(&quot;Amy&quot;,&quot;&quot;);  // Amy,
fn(&quot;Amy&quot;);     // Amy,17

2.0 不定参数
function f(...values){
    console.log(values.length);
}
f(1,2);      //2
f(1,2,3,4);  //4

3.0 箭头函数
</code></pre></div><h2 id="_4-0-symbol-数据类型"><a href="#_4-0-symbol-数据类型" class="header-anchor">#</a> 4.0 Symbol 数据类型</h2> <blockquote><p>ES6 引入了一种新的原始数据类型 Symbol ，表示独一无二的值，最大的用法是用来定义对象的唯一属性名。</p></blockquote> <div class="language- extra-class"><pre class="language-text"><code>let sy = Symbol(&quot;KK&quot;);
console.log(sy);   // Symbol(KK)
typeof(sy);        // &quot;symbol&quot;
 
// 相同参数 Symbol() 返回的值不相等
let sy1 = Symbol(&quot;kk&quot;); 
sy === sy1;       // false
</code></pre></div><p><strong>用法</strong></p> <div class="language- extra-class"><pre class="language-text"><code>let sy = Symbol(&quot;key1&quot;);
 
// 写法1
let syObject = {};
syObject[sy] = &quot;kk&quot;;
console.log(syObject);    // {Symbol(key1): &quot;kk&quot;}
 
// 写法2
let syObject = {
  [sy]: &quot;kk&quot;
};
console.log(syObject);    // {Symbol(key1): &quot;kk&quot;}
 
// 写法3
let syObject = {};
Object.defineProperty(syObject, sy, {value: &quot;kk&quot;});
console.log(syObject);   // {Symbol(key1): &quot;kk&quot;}
</code></pre></div><p><strong>注意点</strong></p> <p>Symbol 值作为属性名时，该属性是公有属性不是私有属性，可以在类的外部访问。但是不会出现在 for...in 、 for...of 的循环中，也不会被 Object.keys() 、 Object.getOwnPropertyNames() 返回。如果要读取到一个对象的 Symbol 属性，可以通过 Object.getOwnPropertySymbols() 和 Reflect.ownKeys() 取到。</p> <div class="language- extra-class"><pre class="language-text"><code> let syObject = {};
 syObject[sy] = &quot;kk&quot;;
 console.log(syObject);
  
 for (let i in syObject) {
   console.log(i);
 }    // 无输出
  
 Object.keys(syObject);                     // []
 Object.getOwnPropertySymbols(syObject);    // [Symbol(key1)]
 Reflect.ownKeys(syObject);                 // [Symbol(key1)]
</code></pre></div><h2 id="_5-0-set-对象-和map对象"><a href="#_5-0-set-对象-和map对象" class="header-anchor">#</a> 5.0 Set 对象 和map对象</h2> <blockquote><p>Set 对象允许你存储任何类型的唯一值，无论是原始值或者是对象引用。<br>
Set 中的特殊值<br></p></blockquote> <p>Set 对象存储的值总是唯一的，所以需要判断两个值是否恒等。有几个特殊值需要特殊对待：<br></p> <ul><li>+0 与 -0 在存储判断唯一性的时候是恒等的，所以不重复；
*undefined 与 undefined 是恒等的，所以不重复；</li> <li>NaN 与 NaN 是不恒等的，但是在 Set 中只能存一个，不重复。</li></ul> <div class="language- extra-class"><pre class="language-text"><code> let mySet = new Set();
  
 mySet.add(1); // Set(1) {1}
 mySet.add(5); // Set(2) {1, 5}
 mySet.add(5); // Set(2) {1, 5} 这里体现了值的唯一性
 mySet.add(&quot;some text&quot;); 
 // Set(3) {1, 5, &quot;some text&quot;} 这里体现了类型的多样性
 var o = {a: 1, b: 2}; 
 mySet.add(o);
 mySet.add({a: 1, b: 2}); 
 // Set(5) {1, 5, &quot;some text&quot;, {…}, {…}} 
 // 这里体现了对象之间引用不同不恒等，即使值相同，Set 也能存储
</code></pre></div><p><strong>类型转换</strong></p> <div class="language- extra-class"><pre class="language-text"><code> // Array 转 Set
 var mySet = new Set([&quot;value1&quot;, &quot;value2&quot;, &quot;value3&quot;]);
 // 用...操作符，将 Set 转 Array
 var myArray = [...mySet];
 String
 // String 转 Set
 var mySet = new Set('hello');  // Set(4) {&quot;h&quot;, &quot;e&quot;, &quot;l&quot;, &quot;o&quot;}
 // 注：Set 中 toString 方法是不能将 Set 转换成 String
</code></pre></div><p><strong>Set 对象作用</strong></p> <div class="language- extra-class"><pre class="language-text"><code> 1.0 数组去重
var mySet = new Set([1, 2, 3, 4, 4]);
[...mySet]; // [1, 2, 3, 4]

2.0 并集
var a = new Set([1, 2, 3]);
var b = new Set([4, 3, 2]);
var union = new Set([...a, ...b]); // {1, 2, 3, 4}

3.0 交集

var a = new Set([1, 2, 3]);
var b = new Set([4, 3, 2]);
var intersect = new Set([...a].filter(x =&gt; b.has(x))); // {2, 3}

4.0 差集
var a = new Set([1, 2, 3]);
var b = new Set([4, 3, 2]);
var difference = new Set([...a].filter(x =&gt; !b.has(x))); // {1}
</code></pre></div><p>Set常用属性及增删改查方法:</p> <ul><li>size属性: 返回集合的元素个数。（类似数组的长度length）</li> <li>add(value)方法: 向集合中添加一个元素value。注意：如果向集合中添加一个已经存在的元素，不报错但是集合不会改变。</li> <li>delete(value)方法: 从集合中删除元素value。</li> <li>has(value)方法: 判断value是否在集合中，返回true或false.</li> <li>clear()方法: 清空集合。</li></ul> <div class="language- extra-class"><pre class="language-text"><code> let mySet = new Set([1, 2, 3, 2, 1]);
 console.log(mySet.size);   //3
 console.log(...mySet);      //1,2,3
 mySet.add(4);
 console.log(mySet.size);   //4
 mySet.delete(3);
 console.log(mySet.size);  //3
 console.log(mySet.has(2));  //true
 mySet.clear();
 console.log(mySet.size);  //0
</code></pre></div><p><strong>Map(字典)：</strong>
集合与字典的区别:</p> <ul><li>同: 集合和字典都是存储不重复的值.</li> <li>异: 集合中是以[value,value]存储的，字典中是以[key,value]存储的。</li></ul> <p>Map 对象保存键值对。任何值(对象或者原始值) 都可以作为一个键或一个值。
<strong>Maps 和 Objects 的区别</strong></p> <ul><li>一个 Object 的键只能是字符串或者 Symbols，但一个 Map 的键可以是任意值。</li> <li>Map 中的键值是有序的（FIFO 原则），而添加到对象中的键则不是。</li> <li>Map 的键值对个数可以从 size 属性获取，而 Object 的键值对个数只能手动计算。</li> <li>Object 都有自己的原型，原型链上的键名有可能和你自己在对象上的设置的键名产生冲突。</li></ul> <p><strong>Map 中的 key</strong></p> <div class="language- extra-class"><pre class="language-text"><code>1. key 是字符串
var myMap = new Map();
var keyString = &quot;a string&quot;; 
 
myMap.set(keyString, &quot;和键'a string'关联的值&quot;);
 
myMap.get(keyString);    // &quot;和键'a string'关联的值&quot;
myMap.get(&quot;a string&quot;);   // &quot;和键'a string'关联的值&quot;
                         // 因为 keyString === 'a string'

2.0 key 是对象
var myMap = new Map();
var keyObj = {}, 
 
myMap.set(keyObj, &quot;和键 keyObj 关联的值&quot;);
﻿
myMap.get(keyObj); // &quot;和键 keyObj 关联的值&quot;
myMap.get({}); // undefined, 因为 keyObj !== {}

3.0 key 是函数
var myMap = new Map();
var keyFunc = function () {}, // 函数
 
myMap.set(keyFunc, &quot;和键 keyFunc 关联的值&quot;);
 
myMap.get(keyFunc); // &quot;和键 keyFunc 关联的值&quot;
myMap.get(function() {}) // undefined, 因为 keyFunc !== function () {}

4.0 key 是 NaN
var myMap = new Map();
myMap.set(NaN, &quot;not a number&quot;);
 
myMap.get(NaN); // &quot;not a number&quot;
 
var otherNaN = Number(&quot;foo&quot;);
myMap.get(otherNaN); // &quot;not a number&quot;
虽然 NaN 和任何值甚至和自己都不相等(NaN !== NaN 返回true)，NaN作为Map的键来说是没有区别的。
</code></pre></div><p><strong>Map 的迭代</strong></p> <div class="language- extra-class"><pre class="language-text"><code> 1.0 for...of
var myMap = new Map();
myMap.set(0, &quot;zero&quot;);
myMap.set(1, &quot;one&quot;);
 
// 将会显示两个 log。 一个是 &quot;0 = zero&quot; 另一个是 &quot;1 = one&quot;
for (var [key, value] of myMap) {
  console.log(key + &quot; = &quot; + value);
}
for (var [key, value] of myMap.entries()) {
  console.log(key + &quot; = &quot; + value);
}
/* 这个 entries 方法返回一个新的 Iterator 对象，它按插入顺序包含了 Map 对象中每个元素的 [key, value] 数组。 */
 
// 将会显示两个log。 一个是 &quot;0&quot; 另一个是 &quot;1&quot;
for (var key of myMap.keys()) {
  console.log(key);
}
/* 这个 keys 方法返回一个新的 Iterator 对象， 它按插入顺序包含了 Map 对象中每个元素的键。 */
 
// 将会显示两个log。 一个是 &quot;zero&quot; 另一个是 &quot;one&quot;
for (var value of myMap.values()) {
  console.log(value);
}
/* 这个 values 方法返回一个新的 Iterator 对象，它按插入顺序包含了 Map 对象中每个元素的值。 */

2.0 forEach()
var myMap = new Map();
myMap.set(0, &quot;zero&quot;);
myMap.set(1, &quot;one&quot;);
 
// 将会显示两个 logs。 一个是 &quot;0 = zero&quot; 另一个是 &quot;1 = one&quot;
myMap.forEach(function(value, key) {
  console.log(key + &quot; = &quot; + value);
}, myMap)
</code></pre></div><p><strong>Map 对象的操作</strong></p> <div class="language- extra-class"><pre class="language-text"><code>1.0 Map 与 Array的转换
var kvArray = [[&quot;key1&quot;, &quot;value1&quot;], [&quot;key2&quot;, &quot;value2&quot;]];
 
// Map 构造函数可以将一个 二维 键值对数组转换成一个 Map 对象
var myMap = new Map(kvArray);
 
// 使用 Array.from 函数可以将一个 Map 对象转换成一个二维键值对数组
var outArray = Array.from(myMap);

2.0 Map 的克隆
var myMap1 = new Map([[&quot;key1&quot;, &quot;value1&quot;], [&quot;key2&quot;, &quot;value2&quot;]]);
var myMap2 = new Map(myMap1);
 
console.log(original === clone); 
// 打印 false。 Map 对象构造函数生成实例，迭代出新的对象。

3.0 Map 的合并
var first = new Map([[1, 'one'], [2, 'two'], [3, 'three'],]);
var second = new Map([[1, 'uno'], [2, 'dos']]);
 
// 合并两个 Map 对象时，如果有重复的键值，则后面的会覆盖前面的，对应值即 uno，dos， three
var merged = new Map([...first, ...second]);

</code></pre></div><p>Map常用属性及增删改查方法:</p> <ul><li>size: 属性，取出字典的长度</li> <li>set(key, value)：方法，向字典中添加新元素</li> <li>get(key)：方法，通过键查找特定的数值并返回</li> <li>has(key)：方法，判断字典中是否存在键key</li> <li>delete(key)：方法，通过键 key 从字典中移除对应的数据</li> <li>clear()：方法，将这个字典中的所有元素删除</li></ul> <div class="language- extra-class"><pre class="language-text"><code> let myMap = new Map();
 myMap.set(&quot;name&quot;,&quot;Jack&quot;);    
 myMap.set(&quot;age&quot;,&quot;18&quot;);     //添加元素
 console.log(myMap.size);  //2
 console.log(myMap.get(&quot;name&quot;));//Jack
 console.log(myMap.has(&quot;name&quot;)); //true
 myMap.delete(&quot;age&quot;); //删除
 console.log(myMap.size); //1
 console.log(myMap.has(&quot;age&quot;)); //false
 myMap.clear();    //清空元素
 console.log(myMap.size); //0
</code></pre></div><p>Map常用遍历方法:</p> <ul><li>Keys()：将字典中包含的所有键名以迭代器形式返回</li> <li>values()：将字典中包含的所有数值以迭代器形式返回</li> <li>entries()：返回所有成员的迭代器</li> <li>forEach()：遍历字典的所有成员</li></ul> <div class="language- extra-class"><pre class="language-text"><code> let myMap = new Map();
 myMap.set(&quot;name&quot;,&quot;Jack&quot;);
 myMap.set(&quot;age&quot;,&quot;18&quot;);
 myMap.set(&quot;sex&quot;,&quot;man&quot;);
 
 myMap.forEach(
   (value,key,map)=&gt;{
     console.log(value);    //Jack,18,man
     console.log(key);  //name,age,sex
     console.log(map); //自身，自身，自身
   }
 )
</code></pre></div><h2 id="_6-0-es6-reflect-与-proxy"><a href="#_6-0-es6-reflect-与-proxy" class="header-anchor">#</a> 6.0 ES6 Reflect 与 Proxy</h2> <p>Proxy 与 Reflect 是 ES6 为了操作对象引入的 API 。
<br>
Proxy 可以对目标对象的读取、函数调用等操作进行拦截，然后进行操作处理。它不直接操作对象，而是像代理模式，通过对象的代理对象进行操作，在进行这些操作时，可以添加一些需要的额外操作。
<br>
Reflect 可以用于获取目标对象的行为，它与 Object 类似，但是更易读，为操作对象提供了一种更优雅的方式。它的方法与 Proxy 是对应的。<br></p> <p><strong>基本用法</strong>
一个 Proxy 对象由两个部分组成： target 、 handler 。在通过 Proxy 构造函数生成实例对象时，需要提供这两个参数。 target 即目标对象， handler 是一个对象，声明了代理 target 的指定行为。</p> <div class="language- extra-class"><pre class="language-text"><code> let target = {
     name: 'Tom',
     age: 24
 }
 let handler = {
     get: function(target, key) {
         console.log('getting '+key);
         return target[key]; // 不是target.key
     },
     set: function(target, key, value) {
         console.log('setting '+key);
         target[key] = value;
     }
 }
 let proxy = new Proxy(target, handler)
 proxy.name     // 实际执行 handler.get
 proxy.age = 25 // 实际执行 handler.set
 // getting name
 // setting age
 // 25
  
 // target 可以为空对象
 let targetEpt = {}
 let proxyEpt = new Proxy(targetEpt, handler)
 // 调用 get 方法，此时目标对象为空，没有 name 属性
 proxyEpt.name // getting name
 // 调用 set 方法，向目标对象中添加了 name 属性
 proxyEpt.name = 'Tom'
 // setting name
 // &quot;Tom&quot;
 // 再次调用 get ，此时已经存在 name 属性
 proxyEpt.name
 // getting name
 // &quot;Tom&quot;
  
 // 通过构造函数新建实例时其实是对目标对象进行了浅拷贝，因此目标对象与代理对象会互相
 // 影响
 targetEpt)
 // {name: &quot;Tom&quot;}
  
 // handler 对象也可以为空，相当于不设置拦截操作，直接访问目标对象
 let targetEmpty = {}
 let proxyEmpty = new Proxy(targetEmpty,{})
 proxyEmpty.name = &quot;Tom&quot;
 targetEmpty) // {name: &quot;Tom&quot;}
</code></pre></div><p><strong>实例方法</strong></p> <blockquote><p>get(target, propKey, receiver)</p></blockquote> <p>用于 target 对象上 propKey 的读取操作。</p> <div class="language- extra-class"><pre class="language-text"><code> let exam ={
     name: &quot;Tom&quot;,
     age: 24
 }
 let proxy = new Proxy(exam, {
   get(target, propKey, receiver) {
     console.log('Getting ' + propKey);
     return target[propKey];
   }
 })
 proxy.name 
 // Getting name
 // &quot;Tom&quot;
</code></pre></div><p>get() 方法可以继承。</p> <div class="language- extra-class"><pre class="language-text"><code> let proxy = new Proxy({}, {
   get(target, propKey, receiver) {
       // 实现私有属性读取保护
       if(propKey[0] === '_'){
           throw new Erro(`Invalid attempt to get private     &quot;${propKey}&quot;`);
       }
       console.log('Getting ' + propKey);
       return target[propKey];
   }
 });
  
 let obj = Object.create(proxy);
 obj.name
 // Getting name
</code></pre></div><blockquote><p>set(target, propKey, value, receiver)</p></blockquote> <p>用于拦截 target 对象上的 propKey 的赋值操作。如果目标对象自身的某个属性，不可写且不可配置，那么set方法将不起作用。</p> <div class="language- extra-class"><pre class="language-text"><code> let validator = {
     set: function(obj, prop, value) {
         if (prop === 'age') {
             if (!Number.isInteger(value)) {
                 throw new TypeError('The age is not an integer');
             }
             if (value &gt; 200) {
                 throw new RangeError('The age seems invalid');
             }
         }
         // 对于满足条件的 age 属性以及其他属性，直接保存
         obj[prop] = value;
     }
 };
 let proxy= new Proxy({}, validator)
 proxy.age = 100;
 proxy.age           // 100
 proxy.age = 'oppps' // 报错
 proxy.age = 300     // 报错
</code></pre></div><p>第四个参数 receiver 表示原始操作行为所在对象，一般是 Proxy 实例本身。</p> <div class="language- extra-class"><pre class="language-text"><code> const handler = {
     set: function(obj, prop, value, receiver) {
         obj[prop] = receiver;
     }
 };
 const proxy = new Proxy({}, handler);
 proxy.name= 'Tom';
 proxy.name=== proxy // true
  
 const exam = {}
 Object.setPrototypeOf(exam, proxy)
 exam.name = &quot;Tom&quot;
 exam.name === exam // true
</code></pre></div><p>注意，严格模式下，set代理如果没有返回true，就会报错。</p> <p><strong>apply(target, ctx, args)</strong><br>
用于拦截函数的调用、call 和 reply 操作。target 表示目标对象，ctx 表示目标对象上下文，args 表示目标对象的参数数组。</p> <div class="language- extra-class"><pre class="language-text"><code> function sub(a, b){
     return a - b;
 }
 let handler = {
     apply: function(target, ctx, args){
         console.log('handle apply');
         return Reflect.apply(...arguments);
     }
 }
 let proxy = new Proxy(sub, handler)
 proxy(2, 1) 
 // handle apply
 // 1
</code></pre></div><blockquote><p>has(target, propKey)</p></blockquote> <p>用于拦截 HasProperty 操作，即在判断 target 对象是否存在 propKey 属性时，会被这个方法拦截。此方法不判断一个属性是对象自身的属性，还是继承的属性。</p> <div class="language- extra-class"><pre class="language-text"><code> let  handler = {
     has: function(target, propKey){
         console.log(&quot;handle has&quot;);
         return propKey in target;
     }
 }
 let exam = {name: &quot;Tom&quot;}
 let proxy = new Proxy(exam, handler)
 'name' in proxy
 // handle has
 // true
注意：此方法不拦截 for ... in 循环。
</code></pre></div><blockquote><p>construct(target, args)</p></blockquote> <p>用于拦截 new 命令。返回值必须为对象。</p> <div class="language- extra-class"><pre class="language-text"><code> let handler = {
     construct: function (target, args, newTarget) {
         console.log('handle construct')
         return Reflect.construct(target, args, newTarget)  
     }
 }
 class Exam { 
     constructor (name) {  
         this.name = name 
     }
 }
 let ExamProxy = new Proxy(Exam, handler)
 let proxyObj = new ExamProxy('Tom')
 console.log(proxyObj)
 // handle construct
 // exam {name: &quot;Tom&quot;}
</code></pre></div><blockquote><p>deleteProperty(target, propKey)</p></blockquote> <p>用于拦截 delete 操作，如果这个方法抛出错误或者返回 false ，propKey 属性就无法被 delete 命令删除。</p> <blockquote><p>defineProperty(target, propKey, propDesc)</p></blockquote> <p>用于拦截 Object.definePro若目标对象不可扩展，增加目标对象上不存在的属性会报错；若属性不可写或不可配置，则不能改变这些属性。</p> <div class="language- extra-class"><pre class="language-text"><code> let handler = {
     defineProperty: function(target, propKey, propDesc){
         console.log(&quot;handle defineProperty&quot;);
         return true;
     }
 }plet target = {}
 let proxy = new Proxy(target, handler)
 proxy.name = &quot;Tom&quot;
 // handle defineProperty
 target
 // {name: &quot;Tom&quot;}
  
 // defineProperty 返回值为false，添加属性操作无效
 let handler1 = {
     defineProperty: function(target, propKey, propDesc){
         console.log(&quot;handle defineProperty&quot;);
         return false;
     }
 }
 let target1 = {}
 let proxy1 = new Proxy(target1, handler1)
 proxy1.name = &quot;Jerry&quot;
 target1
 // {}
</code></pre></div><p>erty 操作</p> <blockquote><p>getOwnPropertyDescriptor(target, propKey)</p></blockquote> <p>用于拦截 Object.getOwnPropertyD() 返回值为属性描述对象或者 undefined 。</p> <div class="language- extra-class"><pre class="language-text"><code> let handler = {
     getOwnPropertyDescriptor: function(target, propKey){
         return Object.getOwnPropertyDescriptor(target, propKey);
     }
 }
 let target = {name: &quot;Tom&quot;}
 let proxy = new Proxy(target, handler)
 Object.getOwnPropertyDescriptor(proxy, 'name')
 // {value: &quot;Tom&quot;, writable: true, enumerable: true, configurable: 
 // true}
</code></pre></div><p>ptor 属性</p> <blockquote><p>getPrototypeOf(target)</p></blockquote> <p>主要用于拦截获取对象原型的操作。包括以下操作：</p> <div class="language- extra-class"><pre class="language-text"><code>- Object.prototype._proto_
- Object.prototype.isPrototypeOf()
- Object.getPrototypeOf()
- Reflect.getPrototypeOf()
- instanceof

let exam = {}
let proxy = new Proxy({},{
    getPrototypeOf: function(target){
        return exam;
    }
})
Object.getPrototypeOf(proxy) // {} 
</code></pre></div><p>注意，返回值必须是对象或者 null ，否则报错。另外，如果目标对象不可扩展（non-extensible），getPrototypeOf 方法必须返回目标对象的原型对象。</p> <div class="language- extra-class"><pre class="language-text"><code>let proxy = new Proxy({},{
    getPrototypeOf: function(target){
        return true;
    }
})
Object.getPrototypeOf(proxy)
// TypeError: 'getPrototypeOf' on proxy: trap returned neither object // nor null 
</code></pre></div><blockquote><p>isExtensible(target)</p></blockquote> <p>用于拦截 Object.isExtensible 操作。
<br>
该方法只能返回布尔值，否则返回值会被自动转为布尔值</p> <div class="language- extra-class"><pre class="language-text"><code>let proxy = new Proxy({},{
    isExtensible:function(target){
        return true;
    }
})
Object.isExtensible(proxy) // true

注意：它的返回值必须与目标对象的isExtensible属性保持一致，否则会抛出错误。

let proxy = new Proxy({},{
    isExtensible:function(target){
        return false;
    }
})
Object.isExtensible(proxy)
// TypeError: 'isExtensible' on proxy: trap result does not reflect 
// extensibility of proxy target (which is 'true') 
</code></pre></div><blockquote><p>ownKeys(target)</p></blockquote> <p>用于拦截对象自身属性的读取操作。主要包括以下操作：</p> <div class="language- extra-class"><pre class="language-text"><code> - Object.getOwnPropertyNames()
 - Object.getOwnPropertySymbols()
 - Object.keys()
 - or...in

方法返回的数组成员，只能是字符串或 Symbol 值，否则会报错。

若目标对象中含有不可配置的属性，则必须将这些属性在结果中返回，否则就会报错。

若目标对象不可扩展，则必须全部返回且只能返回目标对象包含的所有属性，不能包含不存在的属性，否则也会报错。

let proxy = new Proxy( {
  name: &quot;Tom&quot;,
  age: 24
}, {
    ownKeys(target) {
        return ['name'];
    }
});
Object.keys(proxy)
// [ 'name' ]f返回结果中，三类属性会被过滤：
//          - 目标对象上没有的属性
//          - 属性名为 Symbol 值的属性
//          - 不可遍历的属性
 
let target = {
  name: &quot;Tom&quot;,
  [Symbol.for('age')]: 24,
};
// 添加不可遍历属性 'gender'
Object.defineProperty(target, 'gender', {
  enumerable: false,
  configurable: true,
  writable: true,
  value: 'male'
});
let handler = {
    ownKeys(target) {
        return ['name', 'parent', Symbol.for('age'), 'gender'];
    }
};
let proxy = new Proxy(target, handler);
Object.keys(proxy)
// ['name']
</code></pre></div><blockquote><p>preventExtensions(target)</p></blockquote> <p>拦截 Object.preventExtensions 操作。
<br>
该方法必须返回一个布尔值，否则会自动转为布尔值。</p> <div class="language- extra-class"><pre class="language-text"><code> // 只有目标对象不可扩展时（即 Object.isExtensible(proxy) 为 false ），
 // proxy.preventExtensions 才能返回 true ，否则会报错
 var proxy = new Proxy({}, {
   preventExtensions: function(target) {
     return true;
   }
 });
 // 由于 proxy.preventExtensions 返回 true，此处也会返回 true，因此会报错
 Object.preventExtensions(proxy) 被// TypeError: 'preventExtensions' on proxy: trap returned truish but // the proxy target is extensible
  
 // 解决方案
  var proxy = new Proxy({}, {
   preventExtensions: function(target) {
     // 返回前先调用 Object.preventExtensions
     Object.preventExtensions(target);
     return true;
   }
 });
 Object.preventExtensions(proxy)
 // Proxy {}
</code></pre></div><blockquote><p>setPrototypeOf</p></blockquote> <p>主要用来拦截 Object.setPrototypeOf 方法。
<br>
返回值必须为布尔值，否则会被自动转为布尔值。
<br>
若目标对象不可扩展，setPrototypeOf 方法不得改变目标对象的原型。</p> <div class="language- extra-class"><pre class="language-text"><code> et proto = {}
 let proxy = new Proxy(function () {}, {
     setPrototypeOf: function(target, proto) {
         console.log(&quot;setPrototypeOf&quot;);
         return true;
     }
 }
 );
 Object.setPrototypeOf(proxy, proto);
 // setPrototypeOf
</code></pre></div><blockquote><p>Proxy.revocable()</p></blockquote> <p>用于返回一个可取消的 Proxy 实例。</p> <div class="language- extra-class"><pre class="language-text"><code> let {proxy, revoke} = Proxy.revocable({}, {});
 proxy.name = &quot;Tom&quot;;
 revoke();
 proxy.name 
 // TypeError: Cannot perform 'get' on a proxy that has been revoked
</code></pre></div><h2 id="_7-0-es6-迭代器"><a href="#_7-0-es6-迭代器" class="header-anchor">#</a> 7.0 ES6 迭代器</h2> <p><strong>iterator</strong><br>
iterator 是 ES6 引入的一种新的遍历机制，迭代器有两个核心概念：</p> <ul><li>迭代器是一个统一的接口，它的作用是使各种数据结构可被便捷的访问，它是通过一个键为Symbol.iterator 的方法来实现。<br></li> <li>迭代器是用于遍历数据结构元素的指针（如数据库中的游标）。<br></li></ul> <p><strong>迭代过程</strong><br>
迭代的过程如下：</p> <ul><li>通过 Symbol.iterator 创建一个迭代器，指向当前数据结构的起始位置</li> <li>随后通过 next 方法进行向下迭代指向下一个位置， next 方法会返回当前位置的对象，对象包含了 value 和 done 两个属性， value 是当前属性的值， done 用于判断是否遍历结束</li> <li>当 done 为 true 时则遍历结束</li></ul> <div class="language- extra-class"><pre class="language-text"><code>const items = [&quot;zero&quot;, &quot;one&quot;, &quot;two&quot;];
const it = items[Symbol.iterator]();
 
it.next();
&gt;{value: &quot;zero&quot;, done: false}
it.next();
&gt;{value: &quot;one&quot;, done: false}
it.next();
&gt;{value: &quot;two&quot;, done: false}
it.next();
&gt;{value: undefined, done: true} 
</code></pre></div><p>可迭代的数据结构</p> <ol><li>Array</li> <li>String</li> <li>Map</li> <li>Set</li> <li>arguments</li></ol> <p><strong>for...of 循环对数据结构进行迭代</strong></p> <div class="language- extra-class"><pre class="language-text"><code>for (let item of [&quot;zero&quot;, &quot;one&quot;, &quot;two&quot;]) {
  console.log(item);
}
// zero
// one
// two 
for in 不能遍历 map set结构
for of 不能遍历对象
for…of循环的是的是可迭代对象的value（值），in循环的是可迭代对象的key（属性）
</code></pre></div></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/dist/page-http/http-4/" class="prev">
        前端安全
      </a></span> <span class="next"><a href="/dist/page-es6/es6-2/">
        es6 相关知识点2
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/dist/assets/js/app.d79bc38e.js" defer></script><script src="/dist/assets/js/2.a6a1bbd9.js" defer></script><script src="/dist/assets/js/49.83c72d63.js" defer></script>
  </body>
</html>
