(window.webpackJsonp=window.webpackJsonp||[]).push([[64],{112:function(e,n,t){"use strict";t.r(n);var a=t(0),r=Object(a.a)({},(function(){var e=this,n=e.$createElement,t=e._self._c||n;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("h2",{attrs:{id:"vue面试题"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#vue面试题"}},[e._v("#")]),e._v(" vue面试题")]),e._v(" "),t("h2",{attrs:{id:"mvvm定义"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#mvvm定义"}},[e._v("#")]),e._v(" Mvvm定义")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("MVVM是Model-View-ViewModel的简写。即模型-视图-视图模型。\n【模型】指的是后端传递的数据。\n【视图】指的是所看到的页面。\n【视图模型】mvvm模式的核心，它是连接view和model的桥梁。\n\n 它有两个方向：\n    一是将【模型】转化成【视图】，即将后端传递的数据转化成所看到的页面。\n    实现的方式是：数据绑定。\n    二是将【视图】转化成【模型】，即将所看到的页面转化成后端的数据。\n    实现的方式是：DOM 事件监听。\n\n    这两个方向都实现的，我们称之为数据的双向绑定。\n\n    总结：在MVVM的框架下视图和模型是不能直接通信的。\n    它们通过ViewModel来通信，ViewModel通常要实现一个observer观察者，\n    当数据发生变化，ViewModel能够监听到数据的这种变化，\n    然后通知到对应的视图做自动更新，而当用户操作视图，\n    ViewModel也能监听到视图的变化，然后通知数据做改动，\n    这实际上就实现了数据的双向绑定。并且MVVM中的View 和 ViewModel可以互相通信。\n")])])]),t("h2",{attrs:{id:"mvc定义"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#mvc定义"}},[e._v("#")]),e._v(" MVC定义")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("MVC是Model-View- Controller的简写。即模型-视图-控制器。\nM和V指的意思和MVVM中的M和V意思一样。\nC即Controller指的是页面业务逻辑。使用MVC的目的就是将M和V的代码分离。\n\n‘MVC是单向通信。也就是View跟Model，必须通过Controller来承上启下。\nMVC和MVVM的区别并不是VM完全取代了C，\nViewModel存在目的在于抽离Controller中展示的业务逻辑，\n而不是替代Controller，其它视图操作业务等还是应该放在Controller中实现。\n\n也就是说MVVM实现的是业务逻辑组件的重用。\n由于mvc出现的时间比较早，前端并不那么成熟，很多业务逻辑也是在后端实现，\n所以前端并没有真正意义上的MVC模式。而我们今天再次提起MVC，是因为大前端的来到，\n出现了MVVM模式的框架，我们需要了解一下MVVM这种设计模式是如何一步步演变过来的。\n")])])]),t("h2",{attrs:{id:"mvvm框架-vue的介绍"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#mvvm框架-vue的介绍"}},[e._v("#")]),e._v(" MVVM框架:VUE的介绍")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("Vue就是基于MVVM模式实现的一套框架，\n    在vue中：Model:指的是js中的数据，如对象，数组等等。\n    View:指的是页面视图\n    viewModel:指的是vue实例化对象\n为什么说VUE是一个渐进式的javascript框架, 渐进式是什么意思？\n    1.如果你已经有一个现成的服务端应用，你可以将vue 作为该应用的一部分嵌入其中，\n    带来更加丰富的交互体验;\n    2.如果你希望将更多业务逻辑放到前端来实现，\n    那么VUE的核心库及其生态系统也可以满足你的各式需求（core+vuex+vue-route）。\n    和其它前端框架一样，VUE允许你将一个网页分割成可复用的组件，\n    每个组件都包含属于自己的HTML、CSS、JAVASCRIPT以用来渲染网页中相应的地方。\n    3.如果我们构建一个大型的应用，在这一点上，我们可能需要将东西分割成为各自的组件和文件，\n    vue有一个命令行工具，使快速初始化一个真实的工程变得非常简单\n    （vue init webpack my-project）。我们可以使用VUE的单文件组件，\n    它包含了各自的HTML、JAVASCRIPT以及带作用域的CSS或SCSS。\n\n    以上这三个例子，是一步步递进的，也就是说对VUE的使用可大可小，\n    它都会有相应的方式来整合到你的项目中。所以说它是一个渐进式的框架。\n\n    VUE最独特的特性：响应式系统VUE是响应式的（reactive），\n    也就是说当我们的数据变更时，VUE会帮你更新所有网页中用到它的地方。\n")])])]),t("h2",{attrs:{id:"vue-实现双向数据绑定"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#vue-实现双向数据绑定"}},[e._v("#")]),e._v(" vue 实现双向数据绑定")]),e._v(" "),t("p",[e._v("简单的demo")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('<input type="text" id="inp"/>\n<p id="showText"></p>\nvar obj = {};\n　　Object.defineProperty(obj,"newProp",{\n　　　　get:function(){\n　　　　　　return obj;\n　　　　},\n　　　　set:function(newVal){\n　　　　　　document.getElementById("inp").value = newVal;\n　　　　　　document.getElementById("showText").innerHTML = newVal;\n　　　　}\n　　})\n　　document.addEventListener("keyup",function(e){\n　　　　obj.newProp = e.target.value;\n　　})\n')])])]),t("p",[t("a",{attrs:{href:"https://segmentfault.com/a/1190000006599500?utm_source=tag-newest",target:"_blank",rel:"noopener noreferrer"}},[e._v("参考链接"),t("OutboundLink")],1)])])}),[],!1,null,null,null);n.default=r.exports}}]);