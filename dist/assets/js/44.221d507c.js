(window.webpackJsonp=window.webpackJsonp||[]).push([[44],{101:function(n,e,a){"use strict";a.r(e);var t=a(0),r=Object(t.a)({},(function(){var n=this,e=n.$createElement,a=n._self._c||e;return a("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[a("h2",{attrs:{id:"工厂模式"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#工厂模式"}},[n._v("#")]),n._v(" 工厂模式")]),n._v(" "),a("p",[n._v("工厂模式是一种用来创建对象的设计模式。我们不暴露对象创建的逻辑,而是将逻辑封装在一个函数内,那么这个函数可以成为工厂;\n并且是通过使用一个共同的接口来指向新创建的对象，用工厂方法代替new操作的一种模式。")]),n._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[n._v("class Creator {\n    create(name) {\n        return new Animal(name)\n    }\n}\nclass Animal {\n    constructor(name){\n        this.name = name\n    }\n}\n\nvar cretor = new Creator()\n\nvar duck = creator.create('Duck')\nduck.name // Duck\n\nvar chicken = creator.create('Chicken')\nchicken.name // Chicken\n")])])]),a("p",[n._v("1.0 构造函数和创建者分离，对new操作进行封装"),a("br"),n._v("\n2.0 符合开放封闭原则(OCP)")])])}),[],!1,null,null,null);e.default=r.exports}}]);